<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅笑整个夏季</title>
  
  <subtitle>做一个快乐的程序媛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangliminabc.github.io/"/>
  <updated>2021-07-06T13:36:17.000Z</updated>
  <id>http://zhangliminabc.github.io/</id>
  
  <author>
    <name>浅笑整个夏季</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript深入浅出13(es5-generator)</title>
    <link href="http://zhangliminabc.github.io/ecmascript-07-06-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA13-es5-generator/"/>
    <id>http://zhangliminabc.github.io/ecmascript-07-06-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA13-es5-generator/</id>
    <published>2021-07-06T13:36:17.000Z</published>
    <updated>2021-07-06T13:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。<br>一是，<code>function</code>关键字与函数名之间有一个星号；<br>二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ending&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码一共调用了四次<code>next</code>方法。</p><p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p><p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><p>ES6 没有规定，<code>function</code>关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure><p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在<code>function</code>关键字后面。本书也采用这种写法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。&lt;/p&gt;
&lt;p&gt;Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。&lt;/p&gt;
&lt;p&gt;执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。&lt;/p&gt;
&lt;p&gt;形式上，Generator 函数是一个普通函数，但是有两个特征。&lt;br&gt;一是，&lt;code&gt;function&lt;/code&gt;关键字与函数名之间有一个星号；&lt;br&gt;二是，函数体内部使用&lt;code&gt;yield&lt;/code&gt;表达式，定义不同的内部状态（&lt;code&gt;yield&lt;/code&gt;在英语里的意思就是“产出”）。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>javascript深入浅出12(原型链)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA12-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA12-%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2021-07-06T11:43:59.000Z</published>
    <updated>2021-07-06T11:43:59.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="prototype-和-proto"><a href="#prototype-和-proto" class="headerlink" title="prototype 和  proto"></a>prototype 和  <strong>proto</strong></h4><ul><li>每个函数都要一个原型对象（prototype) ， 原型对象包含一个指向构造函数的的指针(constructor)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;prototype-和-proto&quot;&gt;&lt;a href=&quot;#prototype-和-proto&quot; class=&quot;headerlink&quot; title=&quot;prototype 和  proto&quot;&gt;&lt;/a&gt;prototype 和  &lt;strong&gt;proto&lt;/strong
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>重学算法(1)-栈</title>
    <link href="http://zhangliminabc.github.io/algorithm-07-06-%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95-1-%E6%A0%88/"/>
    <id>http://zhangliminabc.github.io/algorithm-07-06-%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95-1-%E6%A0%88/</id>
    <published>2021-07-06T06:04:07.000Z</published>
    <updated>2021-07-06T06:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h4 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h4><p>后进者先出，先进者后出，简称 后进先出（LIFO） </p>1, 新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。2, 在栈里，新元素都靠近栈顶，旧元素都接近栈底。3, 从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。4, 不包含任何元素的栈称为空栈。]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h4&gt;&lt;h4 id=&quot;什么是栈&quot;&gt;&lt;a href=&quot;#什么是栈&quot; class=&quot;headerlink&quot; title=&quot;什么是栈&quot;&gt;&lt;/a&gt;什么是栈&lt;/h4&gt;&lt;p
      
    
    </summary>
    
    
      <category term="algorithm" scheme="http://zhangliminabc.github.io/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
      <category term="algorithm" scheme="http://zhangliminabc.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>css重学(1)-单位</title>
    <link href="http://zhangliminabc.github.io/style-07-05-css%E9%87%8D%E5%AD%A6-1-%E5%8D%95%E4%BD%8D/"/>
    <id>http://zhangliminabc.github.io/style-07-05-css%E9%87%8D%E5%AD%A6-1-%E5%8D%95%E4%BD%8D/</id>
    <published>2021-07-05T11:53:24.000Z</published>
    <updated>2021-07-05T11:53:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="css中的常用单位："><a href="#css中的常用单位：" class="headerlink" title="css中的常用单位："></a>css中的常用单位：</h4><p>设备像素： 设备屏幕实际拥有的像素点； 一般来说： 宽度方向有1920个像素点，长度方向有1080个像素点</p><p>逻辑像素： CSS的像素单位（css的px）其尺寸大小是想相对的， 也称谓独立像素</p><p>分辨率： 屏长的设备像素 * 屏宽的设备像素（1920 * 1080 )</p><p>ppi(pixels per inch): 像素密度，便是沿对角线没英寸长度的像素数目，越大显示的越细腻</p><p>缩放因子： 逻辑像素相对于设备像素的放大比例， 可通过window.devicePixelRatio获得</p><p>分辨率（设备像素） = 设备尺寸 * 像素密度</p><p>关系一：<br>  设备尺寸 × 像素密度 = 分辨率（设备像素）</p><p>举例：<br>  iphone6s 对角线长度为5.5 inches，像素密度401 ppi，分辨率 1920 * 1080，计算可得对角线的设备像素为2205.5。<br>  5.5 * 401 = 2205.5</p><p>关系二：<br>  逻辑像素(css的px) = 设备像素 × 缩放因子</p><p>举例：<br>  iphone6逻辑像素为375 * 667，分辨率为750 * 1334，缩放因子为2<br>  1个逻辑像素（1px） = 设备宽度的1/375<br>  1个设备像素 = 设备宽度的1/750</p><p>px: 独立像素</p><p>em: 根据父元素的字体大小来计算字体大小</p><p>rem: 相对于根元素html字体大小计算字体大小</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> docEl = win.document.documentElement;</span><br><span class="line"><span class="keyword">const</span> resiezeEvt = <span class="string">&#x27;orientationchange&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> refreshRem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> clientWidth = win.innerWidth || doc.documentElement.clientWidth || doc.body.clientWidth;</span><br><span class="line">   <span class="built_in">console</span>.log(clientWidth)</span><br><span class="line">   <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">let</span> fz;</span><br><span class="line">   <span class="keyword">const</span> width = clientWidth;</span><br><span class="line">   fz = <span class="number">16</span> * width / <span class="number">375</span>;</span><br><span class="line">   docEl.style.fontSize = fz + <span class="string">&#x27;px&#x27;</span>;<span class="comment">//这样每一份也是16px,即1rem=16px</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span><br><span class="line"> win.addEventListener(resizeEvt, refreshRem, <span class="literal">false</span>);</span><br><span class="line"> doc.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, refreshRem, <span class="literal">false</span>);</span><br><span class="line"> refreshRem();</span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;css中的常用单位：&quot;&gt;&lt;a href=&quot;#css中的常用单位：&quot; class=&quot;headerlink&quot; title=&quot;css中的常用单位：&quot;&gt;&lt;/a&gt;css中的常用单位：&lt;/h4&gt;&lt;p&gt;设备像素： 设备屏幕实际拥有的像素点； 一般来说： 宽度方向有1920个像素
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://zhangliminabc.github.io/categories/css/"/>
    
    
      <category term="CSS" scheme="http://zhangliminabc.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>重学js值(3)-super</title>
    <link href="http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B-3-super/"/>
    <id>http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B-3-super/</id>
    <published>2021-07-02T08:56:08.000Z</published>
    <updated>2021-07-02T08:56:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="super-用于访问和调用一个对象的父对象上的函数"><a href="#super-用于访问和调用一个对象的父对象上的函数" class="headerlink" title="super: 用于访问和调用一个对象的父对象上的函数"></a>super: 用于访问和调用一个对象的父对象上的函数</h4><h5 id="Object-getPrototypeOf-Object-setPrototypeOf-返回的是对象的隐士的原型对象-proto"><a href="#Object-getPrototypeOf-Object-setPrototypeOf-返回的是对象的隐士的原型对象-proto" class="headerlink" title="Object.getPrototypeOf / Object.setPrototypeOf: 返回的是对象的隐士的原型对象 proto"></a>Object.getPrototypeOf / Object.setPrototypeOf: 返回的是对象的隐士的原型对象 <strong>proto</strong></h5><h5 id="Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"><a href="#Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。" class="headerlink" title="Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"></a>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</h5><h4 id="babel编译super"><a href="#babel编译super" class="headerlink" title="babel编译super"></a>babel编译super</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">_getPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf ?</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf :</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(o);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> _getPrototypeOf(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_assertThisInitialized</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (self === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">&quot;this hasn&#x27;t been initialised - super() hasn&#x27;t been called&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (call &amp;&amp; (_typeof(call) === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> call === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperMethod</span>(<span class="params">subClass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="function"><span class="keyword">function</span>  <span class="title">_createSuperInternal</span>(<span class="params">subClass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 这两步参考extends</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">super</span> = _getPrototypeOf(subClass)</span><br><span class="line"><span class="keyword">const</span> newTarget =  _getPrototypeOf(<span class="built_in">this</span>).constructor</span><br><span class="line"><span class="comment">/** Reflect.constructor(super, constructor, newTarget) 相当于 =  </span></span><br><span class="line"><span class="comment">var obj2 = Object.create(newTarget.prototype);</span></span><br><span class="line"><span class="comment">super.apply(obj2, args);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">result = <span class="built_in">Reflect</span>.constructor(<span class="built_in">super</span>, <span class="built_in">arguments</span>, newTarget)</span><br><span class="line"><span class="keyword">return</span> _possibleConstructorReturn(<span class="built_in">this</span>, result) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;super-用于访问和调用一个对象的父对象上的函数&quot;&gt;&lt;a href=&quot;#super-用于访问和调用一个对象的父对象上的函数&quot; class=&quot;headerlink&quot; title=&quot;super: 用于访问和调用一个对象的父对象上的函数&quot;&gt;&lt;/a&gt;super: 用于访
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>重学js值(2)-extends</title>
    <link href="http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B(2)-extends/"/>
    <id>http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B(2)-extends/</id>
    <published>2021-07-02T04:11:58.000Z</published>
    <updated>2021-07-02T04:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"><a href="#Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。" class="headerlink" title="Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"></a>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</h5><h4 id="先搞定清楚-prototype-和-proto之间的区别"><a href="#先搞定清楚-prototype-和-proto之间的区别" class="headerlink" title="先搞定清楚 prototype 和 proto之间的区别"></a>先搞定清楚 prototype 和 <strong>proto</strong>之间的区别</h4><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><pre><code>a, 拥有属性的对象不同</code></pre><p><strong>proto</strong>: 在js中， 万物皆为对象，对象具有<strong>proto</strong>属性，可称为隐式原型； 一个对象的隐式原型指向该对象的构造函数的原型（js的对象）</p><p>prototype: 函数这个特殊对象所特有的属性（原型属性）（函数）</p><pre><code>b,  指向不同</code></pre><p>1，<strong>proto</strong> 指向它的构造函数的原型对象（prototype ）</p><p>2，该原型对象也有一个自己的隐式原型( <strong>proto</strong> ) 和 constructor;<br>    constructor: 指向构造函数<br>    <strong>proto</strong>: 指向它的构造函数的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Test.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">Test.prototype.constructor === Test <span class="comment">// true</span></span><br><span class="line">Test.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="extends做了什么？？"><a href="#extends做了什么？？" class="headerlink" title="extends做了什么？？"></a>extends做了什么？？</h4><pre><code>extends在实现继承方面，本质上也是原型链继承,该方法实现了两步原型链继承    1）子类的__proto__属性，表示构造函数的继承，总是指向父类。（把子类构造函数(Child)的原型(__proto__)指向了父类构造函数(Parent)）    2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</code></pre><h4 id="自定义实现extends"><a href="#自定义实现extends" class="headerlink" title="自定义实现extends"></a>自定义实现extends</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">customExtends</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 创建以constructor对象为基准的__proto__ == superClass.prototype</span></span><br><span class="line">subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">      <span class="title">constructor</span>: &#123; </span><br><span class="line">value: subClass,</span><br><span class="line">writable: <span class="literal">true</span>,</span><br><span class="line">configurable: <span class="literal">true</span> </span><br><span class="line">&#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 2. 将子类的隐式原型设置为父类</span></span><br><span class="line">subClass.__proto__ = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="babel编译extends"><a href="#babel编译extends" class="headerlink" title="babel编译extends"></a>babel编译extends</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">&#x27;function&#x27;</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Super expression must either be null or a function &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line"><span class="title">constructor</span>: &#123;</span><br><span class="line">value: subClass,</span><br><span class="line">writable: <span class="literal">true</span>,</span><br><span class="line">configureable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> (superClass) &#123;</span><br><span class="line">_setPrototypeOf(subClass, superClass)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">_setPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf || <span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123; o.__proto__ = p; <span class="keyword">return</span> o&#125;</span><br><span class="line"><span class="comment">// subClass.__proto__ = superClass</span></span><br><span class="line"><span class="keyword">return</span> _setPrototypeOf(subClass, superClass)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。&quot;&gt;&lt;a href=&quot;#Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="JavaScriptj" scheme="http://zhangliminabc.github.io/categories/javascriptj/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>重学js之(1)-new</title>
    <link href="http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B(1)-new/"/>
    <id>http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B(1)-new/</id>
    <published>2021-07-01T12:21:21.000Z</published>
    <updated>2021-07-01T12:21:21.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="new的作用"><a href="#new的作用" class="headerlink" title="new的作用"></a>new的作用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Test(<span class="string">&#x27;测试&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance.name) <span class="comment">// 测试</span></span><br><span class="line"></span><br><span class="line">instance.setName(<span class="string">&#x27;测试1&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance.name) <span class="comment">// 测试1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p> new 通过构造函数创建出来的实例可以访问构造函数中的属性</p><p> new 通过构造函数创建出来的实例可以访问原型链中的属性和方法； 也就是说通过new操作符实例和构造函数通过原型链连接起来了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">age</span>: <span class="number">24</span>&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Test(<span class="string">&#x27;yck&#x27;</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(t) <span class="comment">// &#123; age: 26 &#125;</span></span><br><span class="line">   <span class="built_in">console</span>.log(t.name) <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><p> 构造函数如果返回值为对象，那么这个返回值会被正常使用 </p><h6 id="自定义实现-new-操作符"><a href="#自定义实现-new-操作符" class="headerlink" title="自定义实现 new 操作符"></a>自定义实现 new 操作符</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNew</span>(<span class="params">Con, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">// 解释了static类型的方法不能通过this调用的原因</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, Con.prototype)</span><br><span class="line"><span class="comment">// apply方法调用一个具有给定this值的函数</span></span><br><span class="line"><span class="keyword">let</span> result = Con.apply(<span class="built_in">this</span>, args)</span><br><span class="line"><span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;new的作用&quot;&gt;&lt;a href=&quot;#new的作用&quot; class=&quot;headerlink&quot; title=&quot;new的作用&quot;&gt;&lt;/a&gt;new的作用&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>es深入浅出系列(2)</title>
    <link href="http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-2/"/>
    <id>http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-2/</id>
    <published>2021-06-09T13:22:41.000Z</published>
    <updated>2021-06-09T13:22:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>ES6 允许写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>解构赋值允许指定默认值。</p><p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [firstItem = []] = []</span><br><span class="line"></span><br><span class="line">firstItem <span class="comment">// []; 解构赋值在解构出来的值为undefined时，默认值才会生效</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;解构&quot;&gt;&lt;a href=&quot;#解构&quot; class=&quot;headerlink&quot; title=&quot;解构&quot;&gt;&lt;/a&gt;解构&lt;/h3&gt;&lt;p&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。&lt;/p&gt;
&lt;p&gt;以前，为变量赋值
      
    
    </summary>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/categories/ecmascript/"/>
    
      <category term="javascript" scheme="http://zhangliminabc.github.io/categories/ecmascript/javascript/"/>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>es深入浅出系列(1)</title>
    <link href="http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-1/"/>
    <id>http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-1/</id>
    <published>2021-06-09T12:45:56.000Z</published>
    <updated>2021-06-09T12:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="let和const系列"><a href="#let和const系列" class="headerlink" title="let和const系列"></a>let和const系列</h4><h3 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not undefined</span></span><br><span class="line">b <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p>  const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const PI &#x3D; 3.1415</span><br><span class="line"></span><br><span class="line">PI &#x2F;&#x2F; 3.1415</span><br><span class="line"></span><br><span class="line">pI &#x3D; 3 &#x2F;&#x2F; TypeError: Assignment to constant variable</span><br></pre></td></tr></table></figure><p>const语法对于引用类型是可以更改和增加其属性值， 因为对于引用类型在内存中存储的是一个引用地址； 对于const命令不能将引用地址更改</p><p>1, let 和 const 的出现解决了什么问题？</p><pre><code>在es5中只有全局作用域和函数作用域，带来很多不合理的场景第一种场景： 内层变量覆盖外层变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;这不是时间&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 这不是时间， 原因在于用var 声明的变量存在变量提升， 导致函数执行时在当前函数作用域中就能找到对应的a变量因此进行了输出</span></span><br></pre></td></tr></table></figure>第二中场景： 变量泄露为全局变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= s.length-<span class="number">1</span>; i++</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 5; 原因在于 变量i用var 声明， 导致循环执行结束之后，变量i并没有销毁, 泄露成了全局变量</span></span><br></pre></td></tr></table></figure></code></pre><p>2, let 和const的共同点<br>    1, 没有变量提升<br>    2, 增加了块级作用域<br>    3, 必须先定义后使用, 都存在暂时性死区(在代码块内，使用<code>let</code>和 <code>const</code>命令声明变量之前，该变量都是不可用的变)<br>    4, 在同一个块级作用域中不能重复定义相同的变量</p><p>注意点：</p><ul><li>允许在块级作用域中声明函数</li><li>函数声明类似于 ‘var’，即会提升到全局作用域或者函数作用域的头部（var的变量声明）</li><li>函数声明还会提升到所在的块级作用域的头部</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>相当于运行以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;let和const系列&quot;&gt;&lt;a href=&quot;#let和const系列&quot; class=&quot;headerlink&quot; title=&quot;let和const系列&quot;&gt;&lt;/a&gt;let和const系列&lt;/h4&gt;&lt;h3 id=&quot;let-命令&quot;&gt;&lt;a href=&quot;#let-命令&quot; cla
      
    
    </summary>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/categories/ecmascript/"/>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>webrtc基础概念介绍</title>
    <link href="http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D/"/>
    <id>http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-06-07T11:55:07.000Z</published>
    <updated>2021-06-07T11:55:07.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="webrtc" scheme="http://zhangliminabc.github.io/categories/webrtc/"/>
    
    
      <category term="webrtc" scheme="http://zhangliminabc.github.io/tags/webrtc/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D-2/"/>
    <id>http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D-2/</id>
    <published>2021-06-07T11:53:19.675Z</published>
    <updated>2021-06-07T11:53:19.675Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>nodejs介绍</title>
    <link href="http://zhangliminabc.github.io/nodejs-05-31-nodejs%E4%BB%8B%E7%BB%8D-2/"/>
    <id>http://zhangliminabc.github.io/nodejs-05-31-nodejs%E4%BB%8B%E7%BB%8D-2/</id>
    <published>2021-05-31T08:25:32.000Z</published>
    <updated>2021-05-31T08:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript: 定义了语法（本身只有语法和词法， 简称语法); 比如: 变量定义、循环、判断、函数、原型、原型链、作用域、闭包、异步<br>(ES教程)[<a href="https://es6.ruanyifeng.com/]">https://es6.ruanyifeng.com/]</a></p><p>javascript:  是用ES语法规范 + web API; 两者结合，即可完成浏览器端的任何操作<br>    web Api: BOM、DOM、事件绑定、Ajax、 websock等</p><p>nodejs: 使用ES语法规范 + nodejs api；</p>]]></content>
    
    <summary type="html">
    
      ECMAScript、javascript、nodejs的区别
    
    </summary>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/categories/nodejs/"/>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>nvm控制node版本</title>
    <link href="http://zhangliminabc.github.io/nodejs-05-31-nvm%E6%8E%A7%E5%88%B6node%E7%89%88%E6%9C%AC-1/"/>
    <id>http://zhangliminabc.github.io/nodejs-05-31-nvm%E6%8E%A7%E5%88%B6node%E7%89%88%E6%9C%AC-1/</id>
    <published>2021-05-31T08:19:58.000Z</published>
    <updated>2021-05-31T08:19:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>nvm 控制node 版本</p><p>nvm:  (github地址)[<a href="https://github.com/nvm-sh/nvm]">https://github.com/nvm-sh/nvm]</a></p><p>commender list:</p><ul><li>nvm list</li><li>nvm use</li><li>nvm install</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nvm 控制node 版本&lt;/p&gt;
&lt;p&gt;nvm:  (github地址)[&lt;a href=&quot;https://github.com/nvm-sh/nvm]&quot;&gt;https://github.com/nvm-sh/nvm]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;commender list:&lt;
      
    
    </summary>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/categories/nodejs/"/>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>面试题css(1)</title>
    <link href="http://zhangliminabc.github.io/interview-css-05-26-%E9%9D%A2%E8%AF%95%E9%A2%98css-1/"/>
    <id>http://zhangliminabc.github.io/interview-css-05-26-%E9%9D%A2%E8%AF%95%E9%A2%98css-1/</id>
    <published>2021-05-26T13:03:26.000Z</published>
    <updated>2021-05-26T13:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>常见的css属性  <a href="https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/common-use-css-property.html">常见的属性</a></p></li><li><p>css 盒模型 <a href="https://css.doyoe.com/">盒模型</a></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标准盒模型： width &#x3D; content</span><br><span class="line">ie盒模型： width &#x3D; content + padding + border</span><br><span class="line">不同的浏览器渲染默认对盒模型的渲染是不同的</span><br><span class="line">box-sizing: </span><br></pre></td></tr></table></figure></li><li><p>文档流</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从上到下，从左到右</span><br></pre></td></tr></table></figure></li><li><p>display取值</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. block    独占一行， 可设置宽高内外边距， 默认宽度由父容器决定，默认高度有内容决定</span><br><span class="line">2. inline-block  不独占一行</span><br><span class="line">3. inline 宽度和高度都有内容决定，与其他元素共占一行。</span><br><span class="line">4. table-call</span><br><span class="line">5. none</span><br><span class="line">6. flex 弹性盒不 </span><br></pre></td></tr></table></figure></li><li><p>css 定位</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">relative:  相对不自己本身</span><br><span class="line">absolute: 相对于不是static定位的父级元素</span><br><span class="line">fixed: 相对于可视窗口</span><br><span class="line">static: 默认的</span><br></pre></td></tr></table></figure></li><li><p>css浮动 <a href="http://www.iyunlu.com/view/css-xhtml/55.html">清除浮动</a></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 在浮动元素后添加额外的标签设置为 clear： both</span><br><span class="line">2. 父元素设置： overflow： hidden</span><br><span class="line">3. 使用 after伪类： content:&quot;.&quot;; display:block; height:0; visibility:hidden; clear:both;</span><br></pre></td></tr></table></figure></li></ol><p>5.css选择器<a href="https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css-selector.html">选择器和权重</a></p><p>6.css权重 <a href="http://www.w3cplus.com/css/css-specificity-things-you-should-know.html">权重</a></p><pre><code>从0开始，一个行内样式+1000，一个id+100，一个属性选择器/class或者伪类+10，一个元素名，或者伪元素+1</code></pre><p>7.css书写规范 <a href="http://www.shejidaren.com/css-written-specifications.html">规范</a></p><p>8.flexbox 和 网格布局</p><p>9.请写出如何垂直水平居中div</p><pre><code>分为已知宽高和未知宽高</code></pre><p>10.请简述css3有哪些新特性？</p><pre><code>border-radius,  text-shadow, transform, gradient</code></pre>]]></content>
    
    <summary type="html">
    
      介绍常见的css属性和css的盒模型，解释了display相关取值的区别....等; 汇聚了css相关的面试常考察点
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="CSS编程" scheme="http://zhangliminabc.github.io/categories/interview/css%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>HTML编程系列(1)</title>
    <link href="http://zhangliminabc.github.io/interview-html-05-26-%E9%9D%A2%E8%AF%95%E9%A2%98html-1/"/>
    <id>http://zhangliminabc.github.io/interview-html-05-26-%E9%9D%A2%E8%AF%95%E9%A2%98html-1/</id>
    <published>2021-05-26T12:55:34.000Z</published>
    <updated>2021-05-26T12:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>简述一下你对HTML语义化的理解</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 用正确的标签做正确的事， </span><br><span class="line">2. 有利于搜索引擎的搜索，</span><br><span class="line">3. 有利于阅读源代码或者开发人员更容易将网站分块和阅读</span><br></pre></td></tr></table></figure></li><li><p>请写出行内元素? 块级元素， 空元素有哪些？</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.行内元素： span,  a,  b,  img,  input, select,strong</span><br><span class="line">2.块级元素： div, ol,li,h1-h6,p, ul,table</span><br><span class="line">3. 空元素：br,hr,img, input, link, meta</span><br></pre></td></tr></table></figure></li><li><p>HTML5的form如何关闭自动完成功能？</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不需要提示的form或者某个input设置属性为：  autocomplete&#x3D;off</span><br></pre></td></tr></table></figure></li><li><p>html5有哪些新特性？</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 新增 画板元素 canvas, </span><br><span class="line">2. 视频音频： video, audio,</span><br><span class="line">3. 语义化的标签 header, footer, nav, section, article, calendar(日历), date(日期)， time, email, url, search, </span><br><span class="line">4. 地理定位： Geolocation ( 浏览器对象 navigator)</span><br><span class="line">navigator.geolocation.getCurrentPosition</span><br><span class="line">5. 网络： websocket， webworker （向服务器发送事件）</span><br></pre></td></tr></table></figure></li><li><p>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p></li><li><p>doctype是什么,举例常见doctype及特点</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">doctype: 文档类型</span><br><span class="line">浏览器渲染模式：</span><br><span class="line">非怪异（标准）模式</span><br><span class="line">怪异模式</span><br><span class="line">部分怪异（近乎标准）模式</span><br><span class="line">1. HTML 4.01 strict doctype 适用于验证文档是否符合 HTML 4.01 规范</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;strict.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">2. HTML 4.01 transitional doctype</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">3. HTML 4.01 frameset doctype</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">4. XML 1.0 strict doctype</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Strict&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-strict.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">5. XML 1.0 transitional doctype</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">6. XML 1.0 frameset doctype</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">html 与 xhtml : </span><br><span class="line">html大小写不敏感， xhtml： 元素和属性名大小写敏感，且一律为小写</span><br><span class="line">html： 空元素可以不关闭标签，  xhtml： 每个元素都需要闭合。如果元素内容为空，则需要自闭合</span><br><span class="line">html： 允许使用缩写属性， xhtml： 不允许使用缩写属性，每个属性都需要声明属性名与属性值</span><br></pre></td></tr></table></figure></li><li><p>meta 标签</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. X-UA-Compatible是IE 浏览器一个专有&lt;meta&gt;属性，它告诉IE采用何种IE版本去渲染网页 </span><br><span class="line"> &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot; &#x2F;&gt;</span><br><span class="line">2. content  设置或返回 &lt;meta&gt; 元素的 content 属性的值</span><br><span class="line">3. name 把 content 属性连接到某个名称。</span><br><span class="line">4. scheme 设置或返回用于解释 content 属性的值的格式</span><br><span class="line">5. httpEquiv： 把 content 属性连接到一个 HTTP 头部。</span><br><span class="line"></span><br><span class="line">[ref](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000004279791)</span><br></pre></td></tr></table></figure></li><li><p>浏览器的重绘和回退？</p><pre><code>重绘： 不影响它周围或内部布局的属性， 只是修改元素本身的颜色，文字颜色等回退： 影响它周围或内部布局的属性</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      1,简述一下你对HTML语义化的理解; 2,请写出行内元素? 块级元素， 空元素有哪些？;  3,HTML5的form如何关闭自动完成功能？;.....等，汇聚了HTML相关的面试题和HTML的相关知识点
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="HTML" scheme="http://zhangliminabc.github.io/categories/interview/html/"/>
    
    
      <category term="HTML" scheme="http://zhangliminabc.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>javascript编程系列(5)</title>
    <link href="http://zhangliminabc.github.io/interview-05-14-%E9%9D%A2%E8%AF%95%E9%A2%98js-5/"/>
    <id>http://zhangliminabc.github.io/interview-05-14-%E9%9D%A2%E8%AF%95%E9%A2%98js-5/</id>
    <published>2021-05-14T09:45:41.000Z</published>
    <updated>2021-05-14T09:45:41.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="js编程题" scheme="http://zhangliminabc.github.io/categories/interview/js%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>javascript编程系列(4)</title>
    <link href="http://zhangliminabc.github.io/interview-05-12-%E9%9D%A2%E8%AF%95%E9%A2%98js-4/"/>
    <id>http://zhangliminabc.github.io/interview-05-12-%E9%9D%A2%E8%AF%95%E9%A2%98js-4/</id>
    <published>2021-05-12T02:48:54.000Z</published>
    <updated>2021-05-12T02:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>在一堆正整数中， 找到最长的一组斐波拉契烈段</p><p>  <a href="../../code/findFibonacci.js">源码</a></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFibonacci</span>(<span class="params">inputArr</span>) </span>&#123;</span><br><span class="line">    inputArr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">let</span> startIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> item = []</span><br><span class="line">    <span class="keyword">let</span> current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> lastValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> endIndex = inputArr.length</span><br><span class="line">    <span class="keyword">const</span> numberMap = inputArr.reduce(<span class="function">(<span class="params">pre, num, index</span>) =&gt;</span> &#123;</span><br><span class="line">        pre[num] = index</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isFibona = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = current + next</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> numberMap[value] !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                item.push(current)</span><br><span class="line">            &#125; </span><br><span class="line">            item.push(next)</span><br><span class="line">            current = next</span><br><span class="line">            next = value</span><br><span class="line">            lastValue = value</span><br><span class="line">            <span class="keyword">return</span> numberMap[value]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">startIndex &lt; endIndex</span>)</span> &#123;</span><br><span class="line">        current = inputArr[startIndex]</span><br><span class="line">        next = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (item.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">        item = []</span><br><span class="line">        <span class="keyword">let</span> nextIndex = startIndex + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = nextIndex; i &lt;= endIndex - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            next = inputArr[i]</span><br><span class="line">            <span class="keyword">const</span> index = isFibona()</span><br><span class="line">            <span class="keyword">if</span> (index) &#123;</span><br><span class="line">                i = index - <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        item.push(lastValue)</span><br><span class="line">        startIndex++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> data = result.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.length - b.length)</span><br><span class="line">    <span class="keyword">return</span> data[data.length -<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputArr = [<span class="number">13</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">31</span>, <span class="number">11</span>, <span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findFibonacci(inputArr))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在一堆正整数中， 找到最长的一组斐波拉契烈段
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="js编程题" scheme="http://zhangliminabc.github.io/categories/interview/js%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>javascript编程系列(3)</title>
    <link href="http://zhangliminabc.github.io/interview-05-11-%E9%9D%A2%E8%AF%95%E9%A2%98js-3/"/>
    <id>http://zhangliminabc.github.io/interview-05-11-%E9%9D%A2%E8%AF%95%E9%A2%98js-3/</id>
    <published>2021-05-11T12:15:54.000Z</published>
    <updated>2021-05-11T12:15:54.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>实现一个arrange函数， 可以实现和工作的调度</li></ul>]]></content>
    
    <summary type="html">
    
      实现一个arrange函数， 可以实现和工作的调度
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="js编程题" scheme="http://zhangliminabc.github.io/categories/interview/js%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>javascript编程系列(2)</title>
    <link href="http://zhangliminabc.github.io/interview-05-11-%E9%9D%A2%E8%AF%95%E9%A2%98js-2/"/>
    <id>http://zhangliminabc.github.io/interview-05-11-%E9%9D%A2%E8%AF%95%E9%A2%98js-2/</id>
    <published>2021-05-11T02:23:18.000Z</published>
    <updated>2021-05-11T02:23:18.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>实现一个函数，可以将数组转化为树状数据结构<br> <a href="../../code/buildTreeByArray.js">源码</a></p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">buildTreeByArray</span>(<span class="params">arr1</span>) </span>&#123;    <span class="keyword">const</span> map = arr1.reduce(<span class="function">(<span class="params">pre, item</span>) =&gt;</span> &#123;        <span class="keyword">const</span> &#123; id &#125; = item        pre[id] = item        <span class="keyword">return</span> pre    &#125;, &#123;&#125;)    arr1.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;        <span class="keyword">const</span> &#123; parent_id &#125; = item        <span class="keyword">if</span> (parent_id !== <span class="number">0</span>) &#123;            map[parent_id].children ? map[parent_id].children.push(item) : map[parent_id].children = [item]        &#125;    &#125;)    <span class="keyword">return</span> arr1.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.parent_id === <span class="number">0</span>)&#125;</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      实现一个函数，可以将数组转化为树状数据结构
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="js编程题" scheme="http://zhangliminabc.github.io/categories/interview/js%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>javascript编程系列(1)</title>
    <link href="http://zhangliminabc.github.io/interview-05-10-%E9%9D%A2%E8%AF%95%E9%A2%98js-1/"/>
    <id>http://zhangliminabc.github.io/interview-05-10-%E9%9D%A2%E8%AF%95%E9%A2%98js-1/</id>
    <published>2021-05-10T13:07:57.000Z</published>
    <updated>2021-05-10T13:07:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>实现一个函数，可以对url中的query部分做拆解， 返回一个 key -&gt; value形式的对象<br>  <a href="../../code/querySearch.js">源代码</a></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">querySearch</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!url) <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// const queryParams = url.split(&#x27;?&#x27;)[1] </span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/(?&lt;=\?).*(?=#)/gmi</span></span><br><span class="line">    <span class="keyword">const</span> queryParamsStr = reg.exec(url)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (!queryParamsStr) <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> queryParamsStr.split(<span class="string">&#x27;&amp;&#x27;</span>).reduce(<span class="function">(<span class="params">pre, str</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> [key, value = <span class="string">&#x27;&#x27;</span>] = str.split(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">        key = key.trim()</span><br><span class="line">        value = value.trim()</span><br><span class="line">        pre[key] = value</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(querySearch(<span class="string">&#x27;http://sample.com/?a=1&amp;b=2&amp;c=xx&amp;d#hash&#x27;</span>)) <span class="comment">// &#123; a: &#x27;1&#x27;, b: &#x27;2&#x27;, c: &#x27;xx&#x27;, d: &#x27;&#x27; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      实现一个函数，可以对url中的query部分做拆解， 返回一个 key -&gt; value形式的对象
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="js编程题" scheme="http://zhangliminabc.github.io/categories/interview/js%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
</feed>
