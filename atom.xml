<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅笑整个夏季</title>
  
  <subtitle>做一个快乐的程序媛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangliminabc.github.io/"/>
  <updated>2021-05-08T07:45:28.000Z</updated>
  <id>http://zhangliminabc.github.io/</id>
  
  <author>
    <name>浅笑整个夏季</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript深入浅出10(原型链)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA10(%E5%8E%9F%E5%9E%8B%E9%93%BE)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA10(%E5%8E%9F%E5%9E%8B%E9%93%BE)/</id>
    <published>2021-05-08T07:45:28.000Z</published>
    <updated>2021-05-08T07:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="js-分为函数对象和普通对象"><a href="#js-分为函数对象和普通对象" class="headerlink" title="js 分为函数对象和普通对象"></a>js 分为函数对象和普通对象</h5><ul><li><b>每个对象都有<strong>proto</strong>属性，prototype 属性只有函数对象才有</b></li><li><b>属性<em>proto</em>是一个对象，有 constructor 和<em>proto</em>属性</b></li><li><b>原型对象 prototype 有一个默认的 constructor，记录是由那个构造函数创建的</b></li><li><b>实例(instance)都包含一个指向原型对象的内部指针(<strong>proto</strong>)</b></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment"> * &#123; getFatherValue: function,</span></span><br><span class="line"><span class="comment"> *   constructor: Father()&#123;&#125;,</span></span><br><span class="line"><span class="comment"> *   __proto__: Object</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则三： 原型对象prototype有一个默认的constructor，记录是由那个构造函数创建的</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype.constructor === Father); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">new</span> Father();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   constructor: Father()&#123;&#125;,</span></span><br><span class="line"><span class="comment"> *   __proto__: Object</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Father); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="js-查找规则"><a href="#js-查找规则" class="headerlink" title="js 查找规则"></a>js 查找规则</h5><ul><li><b>如果试图在对象或者实例上查找某个属性，回先从对象内部查找;</b></li><li><b>当查不到的时候，会在该对象的原型中去查找</b></li></ul><p><b style="color:red;">查找对象属性时形成的链式查找叫做原型链（实例和原型的关系）</b></p><h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><p>1, new 操作符内部做了什么</p>  <ul style="color: red;">    <li>创建一个空对象</li>    <li>将空对象的__proto__属性指向实例函数的原型对象(prototype)</li>    <li>使用call绑定函数内的this指向</li>    <li>返回空对象</li>  </ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createdNew</span>(<span class="params">fun1</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = fun1.prototype;</span><br><span class="line">  fun1.call(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="string">&quot;这是父类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = createdNew(Father);</span><br><span class="line"><span class="built_in">console</span>.log(instance1 <span class="keyword">instanceof</span> Father1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>2, 写一个继承函数</p><ul><li><p>组合继承</p><ul><li><p>问题：</p><p>调用了两次父类构造函数(一次为 Son 函数内， 一次为初始化子类实例时), 造成了不必要的消耗</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;black&quot;</span>];</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.sayColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.color.join(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = Parent.prototype;</span><br><span class="line"></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instanceSon = <span class="keyword">new</span> Son(<span class="string">&quot;zhanglimin&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链的查找是根据__proto__一层层向上查找</span></span><br><span class="line"><span class="built_in">console</span>.log(instanceSon.sayAge); <span class="comment">// Function</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype.sayAge); <span class="comment">// Function</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.age); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.sayColor); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li><p>原型继承: 借助原型可以基于已有的对象创建新对象</p><ul><li>问题:<br>对于引用类型的值在实例中数据共享</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  type: [<span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;black&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = object(person);</span><br><span class="line"><span class="built_in">console</span>.log(p1.type); <span class="comment">// [&quot;yellow&quot;, &quot;white&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line">p1.type.push(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = object(person);</span><br><span class="line"><span class="built_in">console</span>.log(p2.type); <span class="comment">// [&quot;yellow&quot;, &quot;white&quot;, &quot;black&quot;, test]</span></span><br></pre></td></tr></table></figure><ul><li>组合继承</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass, parentClass</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createdObjec</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个对象，使对象的__proto__ 指向需要继承的原型</span></span><br><span class="line">  <span class="keyword">const</span> prototype = createdObjec(parentClass.prototype);</span><br><span class="line">  <span class="comment">// constructor指向子类，因为js原型中的规则为constructor指向由谁创建</span></span><br><span class="line">  prototype.constructor = subClass;</span><br><span class="line">  <span class="comment">// 改变子类的原型对象的指向</span></span><br><span class="line">  subClass.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="string">&quot;这是父类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentClass.prototype.syaHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.b = <span class="string">&quot;这是子类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subClass.prototype.saySub = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extend(subClass, parentClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subInstance = <span class="keyword">new</span> subClass();</span><br><span class="line"><span class="built_in">console</span>.log(subInstance.syaHello); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(subInstance.saySub); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>3, 怎么理解原型链: 查找属性时会优先在当前的对象中查找，当查找不到的之后会在对于的原型上查找</p><h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h4><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call函数</a></p><h4 id="封装：属性和方法的封装"><a href="#封装：属性和方法的封装" class="headerlink" title="封装：属性和方法的封装"></a>封装：属性和方法的封装</h4><p>  1, 闭包<br>  2, 对象</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>原型式继承</li></ul><p>原型链实现继承的问题： 数据属性共享， 不能向父类传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型链</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;res&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">instance.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance.colors); <span class="comment">//[&quot;res&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//[&quot;res&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"><span class="comment">// instanceof: 确定实例和原型的关系</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1 <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>构造函数式继承</li></ul><p>问题: 不能继承父类原型链上的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;res&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubClass()</span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperClass) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.getColors()) <span class="comment">// TypeError: instance.getColors is not a function </span></span><br></pre></td></tr></table></figure><ul><li>组合继承</li></ul><p>父类函数执行两次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;block&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instan1 = <span class="keyword">new</span> SubClass(<span class="number">11</span>);</span><br><span class="line">instan1.colors.push(<span class="string">&#x27;test1&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instan1.colors); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27;, &#x27;test1&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instan2 = <span class="keyword">new</span> SubClass(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instan2.colors, <span class="string">&#x27;属性&#x27;</span>); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27; ] 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(instan2.getColors()); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>寄生式继承</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPropotype</span>(<span class="params">ParentClass</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  f.prototype = ParentClass;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ParentClass.prototype.setColors = <span class="function"><span class="keyword">function</span> (<span class="params">colorName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors.push(colorName);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ParentClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ParentClass.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Extends</span>(<span class="params">parent, sub</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = inheritPropotype(parent.prototype);</span><br><span class="line">  p.construcor = sub;</span><br><span class="line">  sub.prototype = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Extends(ParentClass, SubInstance);</span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubInstance();</span><br><span class="line">sub1.setColors(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.getColors());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sub2 = <span class="keyword">new</span> SubInstance();</span><br><span class="line">sub2.setColors(<span class="string">&#x27;block&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub2.getColors());</span><br></pre></td></tr></table></figure><h4 id="多态：-同一种方法多种调用方式"><a href="#多态：-同一种方法多种调用方式" class="headerlink" title="多态： 同一种方法多种调用方式"></a>多态： 同一种方法多种调用方式</h4><p>js中函数参数可以通过arguments获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Polymorphism</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> argsLen = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">if</span> (argsLen &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Polymorphism(<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js的原型链
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出9(闭包)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA9(%E9%97%AD%E5%8C%85)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA9(%E9%97%AD%E5%8C%85)/</id>
    <published>2021-05-08T07:40:19.000Z</published>
    <updated>2021-05-08T07:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><h6 id="js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法"><a href="#js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法" class="headerlink" title="js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法"></a>js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法</h6><h6 id="通俗的解释是函数返回函数，我的理解是"><a href="#通俗的解释是函数返回函数，我的理解是" class="headerlink" title="通俗的解释是函数返回函数，我的理解是"></a>通俗的解释是函数返回函数，我的理解是</h6><h6 id="闭包就是能够读取其他函数内部变量的函数。由于在-Javascript-语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”"><a href="#闭包就是能够读取其他函数内部变量的函数。由于在-Javascript-语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”" class="headerlink" title="闭包就是能够读取其他函数内部变量的函数。由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”"></a>闭包就是能够读取其他函数内部变量的函数。由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”</h6><p><b style="color:red;">所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</b></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;全局属性&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">&quot;这是对象中的值&quot;</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">// My Object</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法， 这就是闭包
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出8(作用域)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA8(%E4%BD%9C%E7%94%A8%E5%9F%9F)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA8(%E4%BD%9C%E7%94%A8%E5%9F%9F)/</id>
    <published>2021-05-08T07:35:47.000Z</published>
    <updated>2021-05-08T07:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作用域-js中的作用域只有函数作用域和全局作用域"><a href="#作用域-js中的作用域只有函数作用域和全局作用域" class="headerlink" title="作用域: (js中的作用域只有函数作用域和全局作用域)"></a>作用域: (js中的作用域只有函数作用域和全局作用域)</h4><p><b>确定当前执行代码对标识符的访问权限</b></p><ul><li><p>函数的作用域: 函数产生一层函数作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(b * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数的作用域</span></span><br><span class="line"><span class="comment"> * 1, 全局window下foo</span></span><br><span class="line"><span class="comment"> * 2, foo下有a, b, bar</span></span><br><span class="line"><span class="comment"> * 3, bar下有c, 当需要查找b，a的值时在当前对象下不能找到会向上级foo下的作用域寻找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">foo(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>模拟块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockBlaockScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// a is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">mockBlaockScope();</span><br></pre></td></tr></table></figure></li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>1, 使用 es5 模拟块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockScoptBlock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;这是块级作用于内的函数&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// error, a is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2, 解决循环输出的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scopeFun();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  output: 5,5,5,5,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案: 使用自执行函数生成函数内的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js中的作用域只有函数作用域和全局作用域
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出7(内存结构)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA7(%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA7(%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84)/</id>
    <published>2021-05-08T07:29:52.000Z</published>
    <updated>2021-05-08T07:29:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>js的内存结构</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></code></pre><p>  将一个对象赋值给obj变量，js引擎会先在队内存中生成一个对象，然将堆内存的地址赋值给变量obj， 所以实际上变量obj指向的是一个堆内存地址</p>   <p style="color: red;">也就是说，变量obj是一个地址（reference）。后面如果要读取obj.a，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的a属性</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">     a: <span class="number">1</span>,</span><br><span class="line">     getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line">obj.f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><img src="../../static/js中的this.png">]]></content>
    
    <summary type="html">
    
      介绍了js变量在电脑中的内存是如何存储的, 堆内存和栈内存的区别以及js对象类型和基础类型数据的存储方式的不同
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出6(this)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA6(this)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA6(this)/</id>
    <published>2021-05-08T07:26:25.000Z</published>
    <updated>2021-05-08T07:26:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html">参考资源-阮一峰this讲解</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">参考资料-mdn</a></p><ul><li><p>普通函数的this指向函数运行时所在的环境</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>) <span class="comment">// true</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li><p>箭头函数指向函数所在的作用域</p></li><li><p>js中this指向的情况</p><ol><li>函数作为对象的属性</li><li><span style="color: red;">通过apply, bind等方法显示改变this的值</span></li><li><span style="color: red;">通过new 关键词实例化函数, this指向初始化的函数</span></li><li>自执行函数中的this指向window</li><li>函数作为对象的属性，但是不通过对象的调用， this指向window</li></ol></li></ul><ul><li>手写模拟apply, call函数<br>  <a href="https://github.com/mqyqingfeng/Blog/issues/11">参考资料</a><br>  <a href="'../../code/call.js">call</a><br>  <a href="'../../code/apply.js">apply</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** apply(需要改变的this值， 参数数组)</span></span><br><span class="line"><span class="comment"> *  output: 返回函数执行的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockApply</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [currentThis, params] = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">    currentThis.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> result = currentThis.fn(...params)</span><br><span class="line">    <span class="keyword">delete</span> currentThis.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.mockCall = mockApply</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">param1, param2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(param1) <span class="comment">// 测试1</span></span><br><span class="line">    <span class="built_in">console</span>.log(param2) <span class="comment">// ceshi12</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> param1</span><br><span class="line">&#125;</span><br><span class="line">f.mockCall(obj1, [<span class="string">&#x27;测试1&#x27;</span>, <span class="string">&#x27;ceshi12&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟化call函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>函数执行的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> params = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">const</span> [ currentThis ]= params</span><br><span class="line">    currentThis.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> result = currentThis.fn(...params.slice(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">delete</span> currentThis.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.mockCall = mockCall</span><br><span class="line"></span><br><span class="line"><span class="comment">//  测试</span></span><br><span class="line"><span class="keyword">var</span> getValue = <span class="function"><span class="keyword">function</span> (<span class="params">paralist</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a) <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(paralist) <span class="comment">// [&#x27;参数1&#x27;, &#x27;参数2&#x27;]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    getValue: getValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getValue.mockCall(obj, [<span class="string">&#x27;参数1&#x27;</span>, <span class="string">&#x27;参数2&#x27;</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      详细介绍了js中的this问题， 区分箭头函数和普通函数下的this的区别
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出5(执行上下文)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA5(%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA5(%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87)/</id>
    <published>2021-05-08T07:03:26.000Z</published>
    <updated>2021-05-08T07:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h4><p><a href="https://www.cnblogs.com/wilber2013/p/4909430.html">参考资料</a></p><p>在JavaScript中有三种代码运行环境</p><ul><li>Global Code: JavaScript代码开始运行的默认环境</li><li>Function Code: 代码进入一个JavaScript函数</li><li>Eval Code: 使用eval()执行代码</li></ul><p>js 代码被执行的时候进入不同的执行环境，这些执行环就构成了执行环境栈（Execution context stack，ECS）</p><img src="../../static/js执行环境栈.png" /><p style="color: red; font-size: 18px;">对于每个Execution Context都有三个重要的属性，变量对象（Variable object，VO），作用域链（Scope chain）和this</p><ul><li><p>VO(variable object):变量对象， 包含当前执行环境的<span style="color: red;">变量 (var, Variable Declaration)， 函数声明 (Function Declaration, FD)， 函数的形参</span></p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">VariableObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.variableDeclaration = &#123;&#125;  <span class="comment">// 变量声明</span></span><br><span class="line">    <span class="built_in">this</span>.functionDeclatration = &#123;&#125; <span class="comment">// 函数声明</span></span><br><span class="line">    <span class="built_in">this</span>.functionArguments = &#123;&#125; <span class="comment">// 函数的形参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>  VO: 对象中不包含函数表达式和没有使用var声明的变量</p></li><li><p>作用域</p></li></ul><ul><li>this属性</li></ul><p>活动对象（Activation object）<br>在函数上下文执行中， vo是不能直接访问的， 此时由激活的对象AO扮演vo角色，激活对象进入函数上下文时被创建， 它是通过函数的arguments属性</p><p>Arguments Object对象包含：</p><ul><li>callee: 指向当前函数的引用</li><li>length: 真正传递的参数个数</li><li>properties-indexes：就是函数的参数值(按参数列表从左到右排列)</li></ul><p>执行环境的创建分为创建阶段和激活/代码执行阶段</p><ul><li><p>创建阶段（当函数被调用，但是开始执行函数内部代码之前）</p><ul><li>创建Scope chain</li><li>创建VO/AO（variables, functions and arguments）</li><li>设置this的值</li></ul></li><li><p>激活/代码执行阶段</p><ul><li>设置变量的值、函数的引用，然后解释/执行代码</li></ul></li></ul><ul><li><p>创建VO/AO</p><ol><li><p>根据函数的参数，创建并初始化arguments object</p></li><li><p>扫描函数内部代码，查找函数声明（Function declaration）<br> a. 对于所有找到的函数声明，将函数名和函数引用存入VO/AO中<br> b. 如果VO/AO中已经有同名的函数，那么就进行覆盖</p></li><li><p>扫描函数内部代码，查找变量声明（Variable declaration）</p></li></ol></li></ul><p>```javascript<br>    // 创建执行环境<br>    function CreateExecutionContext() {<br>        this.status = ‘created’<br>        if (this.status === ‘created’) {<br>            CreatedScopeChin() // 创建作用域连<br>            VariableObject() // 创建VO或者AO对象<br>            SetCurrentThisValue() // 设置当前this的值<br>        }<br>    }</p><pre><code>function demoExecutionContext(param1, param2) &#123;    function demo() &#123;        console.log(&apos;测试&apos;)    &#125;    var demo = &apos;created&apos;    var a = &apos;测试&apos;&#125;demoExecutionContext(&apos;ryfrgyfrgyfr&apos;, &apos;参数以&apos;)// 创阶段demoExecutionContextCreated&#123;    scopeChain: &#123;&#125;,    VO: &#123;        arguments: &#123;            0: &apos; ryfrgyfrgyfr &apos;,            1: &apos;参数以&apos;         &#125;,        param1: &apos; ryfrgyfrgyfr&apos;,        param2: &apos;参数以&apos;,        demo: point to function demo()&#123;.....&#125;,        a: undefined    &#125;,&#125;// 执阶段demoExecutionContextExe&#123;   scopeChain: &#123;&#125;,    VO: &#123;        arguments: &#123;            0: &apos; ryfrgyfrgyfr &apos;,            1: &apos;参数以&apos;         &#125;,        param1: &apos; ryfrgyfrgyfr&apos;,        param2: &apos;参数以&apos;,        demo: &apos;created&apos;,        a: &apos;测试&apos;     &#125;, &#125;</code></pre><p>`</p>]]></content>
    
    <summary type="html">
    
      JavaScript深入浅出三，深入剖析js的执行环境， 充分理解js的作用域； js作用域分为全局作用域和函数作用域，
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出三(语法)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA4(%E8%AF%AD%E6%B3%95)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA4(%E8%AF%AD%E6%B3%95)/</id>
    <published>2021-05-08T06:48:26.000Z</published>
    <updated>2021-05-08T06:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js基础语法"><a href="#js基础语法" class="headerlink" title="js基础语法"></a>js基础语法</h3><pre><code>1. 区分大小写: js 中的变量标识符区分大小写，也就意味这 test/Test 是两个不同的变量2. 标识符: js 中的标识符是指函数名、变量名、参数名等    a. 第一个字符必须是字符、下划线、美元符号    b. 其他字符可以是字母、数字、下划线、美元符号    c. 关键字不能作为标识符3. 注释: 单行注释和多行注释4.  语句: 语句以;结尾        - 虽然分号不是必须的，但是加上也会在某些情况下增加代码的性能5. 变量是松散类型，松散类型可以保存任何类型的数据</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">// 定义变量但未初始化，默认值为undifined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.区分大小写, a 和A 是两个不同的变量。改变其中一个值不会影响另一个变量的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> A = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a == A); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="js-操作符"><a href="#js-操作符" class="headerlink" title="js 操作符"></a>js 操作符</h3><ul><li><p>算数操作符</p><ol><li><p>前置型操作符(前置型递增递减): 执行前置递增或者递减，变量的值都是在被求值以前改变的, 返回的是自增减一之后的值</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> anotherAge = ++age + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// output: 10</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherAge); <span class="comment">// output: 11</span></span><br></pre></td></tr></table></figure></li><li><p>后置操作符(后置型递增递减): 执行递增递减操作是在包它们的语句被求值之后执行， 返回没有自增减之后的值</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age1 = <span class="number">10</span>;</span><br><span class="line">age1++; <span class="comment">// 如果没有对age求值话age1还是10</span></span><br><span class="line"><span class="built_in">console</span>.log(age1); <span class="comment">// output: 11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> num3 = num1-- + num2; <span class="comment">// 22</span></span><br><span class="line"><span class="keyword">var</span> num4 = num1 + num2; <span class="comment">// 21</span></span><br></pre></td></tr></table></figure></li><li><p>一元负值/ 一元正值操作符: <span style="color:red;">以一个+ 放到数值之前，不会对数值有任何影响, 对于非数值应用一元加减操作符，该操作符会像 Number 函数一样对值转型</span>  </p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a. 对于布尔值转成 <span class="number">0</span>|<span class="number">1</span></span><br><span class="line">b. 对于字符串，会按照一定的规则解析</span><br><span class="line">c. 对于对象，会调用 valueof/tostring 方法</span><br></pre></td></tr></table></figure></li></ol></li><li><p>逻辑操作符</p><ol><li><p><span style="color: red;">逻辑非(!): 用于任何类型的值, 在应用的时候会存在类型的转换</span></p><pre><code>对象 -&gt; false空字符串 -&gt; true非空字符串 -&gt; false数值 0 -&gt; true任意非空 0 -&gt; falsenull -&gt; trueNaN -&gt; trueundefined -&gt; true</code></pre></li><li><p><span style="color: red;">逻辑与(||): 当条件满足为真时返回第一个条件为真的值</span></p><pre><code>如果第一个操作符是对象，则直接返回第一个操作符如果第一个操作符的求值结果为 false， 则返回第二个操作符的值如果两个操作符都是对象，则返回第一个操作符如果两个操作符都是 null， 则返回 null如果连个操作符都是 NaN, 则返回 NaN如果两个操作符都是 undefined， 则返回 undefined</code></pre> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> c = &#123; <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">a || c; <span class="comment">// output: a</span></span><br><span class="line"></span><br><span class="line">b || c; <span class="comment">// output: c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> result = found || someUndefinedVar; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">found = <span class="literal">false</span>;</span><br><span class="line">result = found || someUndefinedVar; <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p><span style="color: red;">逻辑与(&amp;&amp;): 短路操作符, 当遇到为false的条件时返回false, 当第一个条件为true， 则返回第二个值</span></p><pre><code>如果第一个操作符是对象，则返回第二个操作符如果第二个操作符是对象，则只有在第一个操作符返回 true 的情况下才会返回此对象两个操作符都是对象，则返回第二个操作符如果有一个操作符是 null，则返回 null如果有一个操作符是 nan， 则返回 nan如果有一个操作符是 undefined, 则返回 undefined</code></pre> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">a &amp;&amp; b; <span class="comment">// output: b</span></span><br><span class="line"></span><br><span class="line">a &amp;&amp; <span class="literal">NaN</span>; <span class="comment">// output: NaN</span></span><br><span class="line"></span><br><span class="line">a &amp;&amp; <span class="literal">undefined</span>; <span class="comment">// output: undefined</span></span><br><span class="line"></span><br><span class="line">a &amp;&amp; <span class="literal">true</span>; <span class="comment">// output: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> founed = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> result = founed &amp;&amp; someUndefinedVar; <span class="comment">// errro:  someUndefinedVar 未定义</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 这句代码不会执行</span></span><br><span class="line"></span><br><span class="line">found = <span class="literal">false</span>;</span><br><span class="line">result = founed &amp;&amp; someUndefinedVar; <span class="comment">// 不会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// output: false</span></span><br></pre></td></tr></table></figure></li><li><p><span style="color: red;">乘法操作符: 如果参与运算的值不是数值型就会使用 Number()函数自动转成数值，然后参与计算</span></p><pre><code>如果有一个值是 NaN, 则返回 NaN如果是 infinity \* 0， 则返回 infinity如果是 infinity 与非 0 数值想剩，则返回 infinity 或者 -infinity如果操作值都是数值，则参与正常的计算，如果超过了 js 的最大限制则返回 infinity 或者 -infinity如果值不为 number 类型则会调用 number()函数转换为数值，在应用上面的规则</code></pre></li></ol></li><li><p>关系操作符</p><ol><li><p><span style="color: red;">instanceof:检测某个对象是不是另一个对象的实例</span></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype) <span class="comment">// &#123;constructor: function Parent()&#123;&#125;, __proto__: Object&#125;</span></span><br><span class="line"><span class="comment">// 理解instanceof 只需要理解下面这句话</span></span><br><span class="line">Parent.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure></li></ol></li><li><p>一元操作符</p><ol><li><p><span style="color: red;">typeof操作符: 判断一个标识符属于哪种数据类型</span></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof 操作符返回值的类型有： &quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot; 和 &quot;undefined&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// Number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;dede&#x27;</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> !!<span class="string">&#x27;0&#x27;</span> <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>() <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="js中的数据类型"><a href="#js中的数据类型" class="headerlink" title="js中的数据类型"></a>js中的数据类型</h4><ul><li><span style="color: red;"> 基本数据类型: undefined、 null、 string、 boolean、 number</span></li><li><span style="color: red;">引用数据类型: object</span></li></ul><h4 id="js中的typeof类型检测函数"><a href="#js中的typeof类型检测函数" class="headerlink" title="js中的typeof类型检测函数"></a>js中的typeof类型检测函数</h4><ul><li>typeof(类型监测)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * undefined: 这个值未定义</span></span><br><span class="line"><span class="comment"> * boolean: 布尔类型</span></span><br><span class="line"><span class="comment"> * string: 字符串</span></span><br><span class="line"><span class="comment"> * number: 数字</span></span><br><span class="line"><span class="comment"> * object: objetc 或者 null</span></span><br><span class="line"><span class="comment"> * function: 函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;这是测试&quot;</span>;</span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;string&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;boolean&quot;</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;number&quot;</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;object&quot;</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;function&quot;</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;undefined&quot;</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="undefined-声明未初始化"><a href="#undefined-声明未初始化" class="headerlink" title="undefined: 声明未初始化"></a>undefined: 声明未初始化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用场景：</span></span><br><span class="line"><span class="comment"> * 1. 变量声明但没赋值</span></span><br><span class="line"><span class="comment"> * 2. 调用函数时该传入的参数没传</span></span><br><span class="line"><span class="comment"> * 3. 函数没有返回值时默认返回undefined</span></span><br><span class="line"><span class="comment"> * 4. 对象中属性值没有赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="null-null-是一个空对象指针-代表的是一个空对象"><a href="#null-null-是一个空对象指针-代表的是一个空对象" class="headerlink" title="null: null 是一个空对象指针,代表的是一个空对象"></a>null: null 是一个空对象指针,代表的是一个空对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 使用场景：</span></span><br><span class="line"><span class="comment"> *  1. 定义的变量在将来用来保存对象</span></span><br><span class="line"><span class="comment"> *  2. 在一个数据不再使用的时候，我们最好将其值设置为null来释放其引用，以便垃圾回收下一次对其回收</span></span><br><span class="line"><span class="comment"> *  3. 作为对象原型链的终端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h4 id="boolean-布尔类型-可以对任意类型的数据结构调用-Boolean-进行转换"><a href="#boolean-布尔类型-可以对任意类型的数据结构调用-Boolean-进行转换" class="headerlink" title="boolean 布尔类型, 可以对任意类型的数据结构调用 Boolean()进行转换"></a>boolean 布尔类型, 可以对任意类型的数据结构调用 Boolean()进行转换</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 转换规则：</span></span><br><span class="line"><span class="comment"> * 1. 字符串： 任意非空类型的字符串-&gt;true, 空类型的字符串-&gt;false</span></span><br><span class="line"><span class="comment"> * 2. number: 任何非0数字,包括正(负)的无穷大-&gt; true,</span></span><br><span class="line"><span class="comment"> * 3. object: 任何对象-&gt;true</span></span><br><span class="line"><span class="comment"> * 4. undefined: undefined -&gt;false</span></span><br><span class="line"><span class="comment"> * 5, null: null -&gt; false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(-<span class="number">0.4774</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="number-数值转换-Number-parseInt-parseFloat"><a href="#number-数值转换-Number-parseInt-parseFloat" class="headerlink" title="number: 数值转换(Number, parseInt, parseFloat)"></a>number: 数值转换(Number, parseInt, parseFloat)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 转换规则</span></span><br><span class="line"><span class="comment"> * 1. boolean: true -&gt; 1, false -&gt; 0</span></span><br><span class="line"><span class="comment"> * 2. number: 简单的传入和返回</span></span><br><span class="line"><span class="comment"> * 3. null: null -&gt; 0</span></span><br><span class="line"><span class="comment"> * 4. undefined: undefined -&gt; 0</span></span><br><span class="line"><span class="comment"> * 5. 字符串: 字符串为空 -&gt; 0; 字符串包含十六进制 -&gt; 转换为十六进制的值; 字符串包含数字 -&gt; 十进制的数值</span></span><br><span class="line"><span class="comment"> * 6. object: 对象 -&gt; valueOf方法按照上述规则转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;hello wrod&quot;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;000011&quot;</span>); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  parseInt: 忽略字符串前面的空格，找到第一个非空字符串，如果第一个字符不是数* 字或者负号返回NaN; 如果第一个字符是数字就会继续解析第二个字符，直到字符不是* 数字为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;1266rhfur&quot;</span>); <span class="comment">// 1266</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;rufgrfr&quot;</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * parseFloat: 从第一个字符开始解析; 解析遇到第一个无效的浮点数字字符或者* 字符串最后为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;23.38434.8484&quot;</span>); <span class="comment">// 23.38434</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;frfr&quot;</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h4 id="string-转为字符串"><a href="#string-转为字符串" class="headerlink" title="string: 转为字符串"></a>string: 转为字符串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 将一个值转为字符串</span></span><br><span class="line"><span class="comment"> *  toString方法</span></span><br><span class="line"><span class="comment"> *  number、boolean、Object、 string都有toString方式, 多数情况下调用toString方法不用传* 参数， 但是对于number类型可以传一个参数代表返回的进制, 一般情况下是以十进制返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="number">11</span>;</span><br><span class="line">message.toString(); <span class="comment">// &#x27;11&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">num.toString(<span class="number">16</span>); <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在不知道转换的值的类型时可以使用String方法转成string类型，然后调用tostring方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">String</span>(a).toString(); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h4 id="object-一组数据和功能的集合-object-是所有它的实例基础"><a href="#object-一组数据和功能的集合-object-是所有它的实例基础" class="headerlink" title="object: 一组数据和功能的集合, object 是所有它的实例基础"></a>object: 一组数据和功能的集合, object 是所有它的实例基础</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** object类型的实例方式</span></span><br><span class="line"><span class="comment"> *  1. hasOwnProperty(propertyName) : 检查给定的属性是否存在当前实例上而不是原型上</span></span><br><span class="line"><span class="comment"> *  2. valueOf: 返回字符串，通常与toString方法返回值相同</span></span><br><span class="line"><span class="comment"> *  3. tostring: 返回对象的字符串标识</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>总结：<br>1, undefined和null的区别<br>    a， undefined表示变量未声明或者声明未赋值； null表示什么都没有<br>    b， js会将未赋值的变量默认值设为undefined； js不会将变量设置为null<br>    c， undefined使用typeof返回值是undefined; null类型返回object</p><p>2, instanceof 和 typeof 的区别？<br>    <span style="color: red;">typeof 用于判断标识符的类型， 但是不能判断对象的类型， 比如data， 数组,对于typeof来讲都是返回object， instanceof用于判断对象是否属于某一个对象的实例， 原型上的相等</span></p>]]></content>
    
    <summary type="html">
    
      介绍了js的基础语法，包含js的基础语法、操作符(算数、关系、逻辑、一元操作符)、 数据类型(null、undefined、string、boolean、number、object)
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出二-js词法分析</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA3(%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA3(%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90)/</id>
    <published>2021-05-08T03:06:27.000Z</published>
    <updated>2021-05-08T03:06:27.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h4><h5 id="之所以叫词法环境，是因为它是和源程序的结构对应，就是和你所写的那些源码的文字的结构对应，你写代码的时候这个环境就定了（写代码的时候决定）"><a href="#之所以叫词法环境，是因为它是和源程序的结构对应，就是和你所写的那些源码的文字的结构对应，你写代码的时候这个环境就定了（写代码的时候决定）" class="headerlink" title="之所以叫词法环境，是因为它是和源程序的结构对应，就是和你所写的那些源码的文字的结构对应，你写代码的时候这个环境就定了（写代码的时候决定）"></a>之所以叫词法环境，是因为它是和源程序的结构对应，就是和你所写的那些源码的文字的结构对应，你写代码的时候这个环境就定了（写代码的时候决定）</h5><h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><pre><code>- 全局词法环境- 函数词法环境- with词法环境- catch词法环境</code></pre><img src="https://user-gold-cdn.xitu.io/2018/12/3/1677429807aea76d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"/><p> 伪代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LexicalEnvironment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.EnvironmentRecord =  <span class="keyword">new</span> EnvironmentRecord()<span class="comment">// 自己的词法环境</span></span><br><span class="line">    <span class="built_in">this</span>.outer = <span class="literal">undefined</span> <span class="comment">// 外部的词法环境的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EnvironmentRecord</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.bindings = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EnvironmentRecord.prototype.rigister = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.bindings.set(name, <span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EnvironmentRecord.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params">name, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.bindings[name] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EnvironmentRecord.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.bindings[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JavaScript深入浅出二， 深度剖析js的词法环境; 之所以叫词法环境，是因为它是和源程序的结构对应，就是和你所写的那些源码的文字的结构对应，你写代码的时候这个环境就定了（写代码的时候决定)
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出零-js整体框架</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA1(%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA1(%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6)/</id>
    <published>2021-05-08T02:47:06.000Z</published>
    <updated>2021-05-08T02:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="javascript-知识架构图"><a href="#javascript-知识架构图" class="headerlink" title="javascript 知识架构图"></a>javascript 知识架构图</h4><img src="../../static/JavaScript.png"/>]]></content>
    
    <summary type="html">
    
      这是js的整体知识框架图以及深入剖析了js代码的执行顺序；在执行的过程中浅析js, js代码分为文法、语法、和执行时三种顺序, 用一定的词法和语法表达一定的语义; js的文法是用一定的表达式和操作符构成一个语句
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出一</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA2(%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA2(%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B)/</id>
    <published>2021-05-06T07:48:42.000Z</published>
    <updated>2021-05-06T07:48:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js引擎的执行流程"><a href="#js引擎的执行流程" class="headerlink" title="js引擎的执行流程"></a>js引擎的执行流程</h3><img src="../../static/js引擎流程.png"><p><a href="https://zhuanlan.zhihu.com/p/96969423">参考资料</a><br><a href="https://juejin.im/post/6844903788629721096">js引擎</a></p><ul><li><p>js的词法分析</p><p> JS文件只是一个源码，机器是无法执行的，词法分析就是把源码的字符串分割出来，生成一系列的token</p> <img src="../../static/js的词法分析.jpg" /></li><li><p>词法分析完后，接下来的阶段就是进行语法分析。语法分析语法分析的输入就是词法分析的输出，输出是AST抽象语法树。当程序出现语法错误的时候，V8在语法分析阶段抛出异常</p>  <img src="../../static/js语法分析.jpg"></li></ul><p>v8引擎解阶段分为预解析和代码执行两阶段， 在预解阶段会有变量预解析和函数预解析</p><ul><li><p>js的字节码生阶段， 根据抽象语法树生成字节码</p> <img src="../../static/js的字节码生成.jpg"></li><li><p>字节码的阶段</p></li></ul>]]></content>
    
    <summary type="html">
    
      JavaScript深入浅出一， 深入剖析js运行机制; js引擎执行流程分为 词法分析 -&gt; 语法分析 -&gt; 预编译-&gt; 生成可执行的字节码
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>git命令详解</title>
    <link href="http://zhangliminabc.github.io/git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhangliminabc.github.io/git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-05-06T03:30:43.000Z</published>
    <updated>2021-05-06T03:30:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="git-安装"><a href="#git-安装" class="headerlink" title="git 安装"></a>git 安装</h4><ol><li>homebrew 安装<br><a href="https://www.jianshu.com/p/7edb6b838a2e">git 安装</a><br><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE">git 资料</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Homebrew</span></span><br><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br><span class="line"><span class="comment"># 安装git</span></span><br><span class="line">brew install git</span><br></pre></td></tr></table></figure><ol start="2"><li><p>git 常用命令：</p><ul><li>git init: 初始化一个 Git 仓库</li><li>git clone: 从远端拉取一个 git 仓库到本地</li><li>git tag: 查看 tag 列表</li><li>git tag ${tagName}: 在当前提交上打上 tag</li><li>git push origin ${tagName}: 把 tagName 提交到代码服务器</li><li>git tag –delete ${tagName}: 删除本地 tag</li><li>git push origin :${tagName} &amp;&amp; git tag –delete ${tagName}: 删除本地和远程的标签</li><li>git symbolic-ref –short HEAD： 获取当前分支的名字</li><li>git remote get-url origin： 获取远程 git 仓库地址</li><li>git tag -l –points-at HEAD： 获取当前 commit 上的 tag</li><li>git branch： 查看所有的分支</li><li>git branch ${tagName} ： 删除本地分支</li><li>git branch -ｒ： 查看远端所有的分支</li><li>git branch -a: 查看本地和远端的分支</li><li>git branch -d: 删除本地分支</li><li>git push origin –delete ${branchName}: 删除远端分支</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;git-安装&quot;&gt;&lt;a href=&quot;#git-安装&quot; class=&quot;headerlink&quot; title=&quot;git 安装&quot;&gt;&lt;/a&gt;git 安装&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;homebrew 安装&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/
      
    
    </summary>
    
    
      <category term="GIT" scheme="http://zhangliminabc.github.io/categories/git/"/>
    
    
      <category term="GIT" scheme="http://zhangliminabc.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>EcmaScript6-generator</title>
    <link href="http://zhangliminabc.github.io/ecmascript6-generator/"/>
    <id>http://zhangliminabc.github.io/ecmascript6-generator/</id>
    <published>2021-05-06T03:28:56.000Z</published>
    <updated>2021-05-06T03:28:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。<br>一是，<code>function</code>关键字与函数名之间有一个星号；<br>二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ending&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码一共调用了四次<code>next</code>方法。</p><p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p><p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><p>ES6 没有规定，<code>function</code>关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure><p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在<code>function</code>关键字后面。本书也采用这种写法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。&lt;/p&gt;
&lt;p&gt;Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。&lt;/p&gt;
&lt;p&gt;执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。&lt;/p&gt;
&lt;p&gt;形式上，Generator 函数是一个普通函数，但是有两个特征。&lt;br&gt;一是，&lt;code&gt;function&lt;/code&gt;关键字与函数名之间有一个星号；&lt;br&gt;二是，函数体内部使用&lt;code&gt;yield&lt;/code&gt;表达式，定义不同的内部状态（&lt;code&gt;yield&lt;/code&gt;在英语里的意思就是“产出”）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="EcmaScript6" scheme="http://zhangliminabc.github.io/categories/ecmascript6/"/>
    
    
      <category term="EcmaScript6" scheme="http://zhangliminabc.github.io/tags/ecmascript6/"/>
    
  </entry>
  
  <entry>
    <title>javascript函数</title>
    <link href="http://zhangliminabc.github.io/javascript%E5%87%BD%E6%95%B0/"/>
    <id>http://zhangliminabc.github.io/javascript%E5%87%BD%E6%95%B0/</id>
    <published>2021-05-06T03:11:35.000Z</published>
    <updated>2021-05-06T03:11:35.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>概述</p><hr style="margin: 5px 0px; background-image: none;     border-top: 1px solid #fff;"/><p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值</p></li><li><p>声明(Function Declaration)</p><hr style="margin: 5px 0px; background-image: none;     border-top: 1px solid #fff;"/><p>1.function 命令声明的代码区块，就是一个函数。function 命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面</p></li></ul>  <a id="more"></a>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  2.函数表达式， 将匿名函数赋值给变量，这是这个匿名函数叫函数表达式</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionVar = <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(params);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 带有函数名的函数表达式</span></span><br><span class="line"><span class="keyword">var</span> funtionWithName = <span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> functionName);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面代码在函数表达式中，加入了函数名functionName。这个functionName只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）</span></span><br><span class="line"><span class="comment">  * ReferenceError: functionName is not defined</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">functionName(<span class="string">&quot;这是参数有参数的函数表达式);</span></span><br></pre></td></tr></table></figure><p>  3.Function 构造函数</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot; return x + y&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  retuen x + u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>函数的重复声明<br>如果同一个函数被多次声明， 后面的会覆盖前面的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;这是第一个函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;这是重复声明的函数， 这个函数会覆盖第一个函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * result =&gt; 这是重复声明的函数， 这个函数会覆盖第一个函数</span></span><br><span class="line"><span class="comment"> * 原因： js中的函数本身属于一个挂载到window对象上的一个属性值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">firstFunc();</span><br></pre></td></tr></table></figure></li><li><p>属性和方法</p></li><li><p>递归</p></li><li><p>作用域</p><p>在 es5 中 JavaScript 只有两种作用域， 一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在</p><p>函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;这是全局作用域的变量&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * result =&gt; 这是全局作用域的变量</span></span><br><span class="line"><span class="comment"> *  在函数体内可以访问具有全局作用域的变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">globalFun();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funVar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">&quot;这是函数体内定义的变量&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReferenceError: b is not defined</span></span><br><span class="line"><span class="comment"> * 函数内定义的变量不能再函数体之外访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果在函数体内存在跟全局变量相同的局部变量，局部变量会覆盖全部变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">f();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(v);</span><br></pre></td></tr></table></figure><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var 命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// firstFun 函数的作用域是全局的</span></span><br><span class="line"><span class="keyword">var</span> firstFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">souncedFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  firstFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * result =&gt; 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">souncedFun();</span><br></pre></td></tr></table></figure></li><li><p>参数</p></li><li><p>闭包<br>定义在函数体内的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parentFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Uncaught ReferenceError: n is not defined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结： 函数内部可以直接读取全局变量，但是函数外部无法读取函数内部声明的变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改造之后的函数体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parentFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * result =&gt; 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(parentFun());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖: 防抖是任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行，一般用于输入框实时搜索</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 节流: 节流是规定函数在指定的时间间隔内只执行一次，一般用于scroll事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>立即调用函数<br>在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;概述&lt;/p&gt;
&lt;hr style=&quot;margin: 5px 0px; background-image: none;     border-top: 1px solid #fff;&quot;/&gt;

&lt;p&gt;函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;声明(Function Declaration)&lt;/p&gt;
&lt;hr style=&quot;margin: 5px 0px; background-image: none;     border-top: 1px solid #fff;&quot;/&gt;

&lt;p&gt;1.function 命令声明的代码区块，就是一个函数。function 命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript面向对象编程</title>
    <link href="http://zhangliminabc.github.io/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://zhangliminabc.github.io/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2021-04-19T11:30:26.000Z</published>
    <updated>2021-04-19T11:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js-对象"><a href="#js-对象" class="headerlink" title="js 对象"></a>js 对象</h3><h4 id="1-对象属性"><a href="#1-对象属性" class="headerlink" title="1. 对象属性"></a>1. 对象属性</h4><p><em>数据属性:</em><br>configurable: 能否通过 delete 删除属性从而重新定义属性，默认值 true<br>enumerable: 是否可以通过 forin 循环， 默认值 true<br>writable: 能否修改属性的值， 默认值 true<br>value： 获取修改属性的值。 默认值 undifined<br>Object.defineProperty( 属性所在的对象， 需要修改的属性名， 描述符对象)</p><p><em>访问器属性：</em><br>configurable: 能否通过 delete 删除属性从而重新定义属性，默认值 true<br>enumerable: 是否可以通过 forin 循环， 默认值 true<br>get: 获取属性值， 默认值 undifined<br>set：设置属性值。 默认值 undifined<br>访问器属性不能直接定义， 只能通过 Object.defineProperty 来定义<br>Object.defineProperties(target， {})</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最新的定义访问器属性的方法</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  year: <span class="number">2004</span>,</span><br><span class="line">  editor: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._year;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._year = newValue + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.year); <span class="comment">//2006</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧版的定义访问器属性的方法</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  year: <span class="number">2004</span>,</span><br><span class="line">  editor: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">book.__defineGetter__(<span class="string">&quot;year&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.year;</span><br><span class="line">&#125;);</span><br><span class="line">book.__defineSetter__(<span class="string">&quot;year&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.year = newValue + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.year); <span class="comment">//2006</span></span><br></pre></td></tr></table></figure><h4 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2. 创建对象"></a>2. 创建对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.job = job;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;校长&quot;</span>, <span class="number">10</span>, <span class="string">&quot;softarea&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">20</span>, <span class="string">&quot;doctor&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;teacher&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;校长&quot;</span>, <span class="number">10</span>, <span class="string">&quot;softarea&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">20</span>, <span class="string">&quot;doctor&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor); <span class="comment">//Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isPrototypeOf： 验证对象之间是否存在关系</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//hasOwnProperty: 验证对象属性是存在于实例中还是原型中</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;js-对象&quot;&gt;&lt;a href=&quot;#js-对象&quot; class=&quot;headerlink&quot; title=&quot;js 对象&quot;&gt;&lt;/a&gt;js 对象&lt;/h3&gt;&lt;h4 id=&quot;1-对象属性&quot;&gt;&lt;a href=&quot;#1-对象属性&quot; class=&quot;headerlink&quot; title=&quot;1. 对象属性&quot;&gt;&lt;/a&gt;1. 对象属性&lt;/h4&gt;&lt;p&gt;&lt;em&gt;数据属性:&lt;/em&gt;&lt;br&gt;configurable: 能否通过 delete 删除属性从而重新定义属性，默认值 true&lt;br&gt;enumerable: 是否可以通过 forin 循环， 默认值 true&lt;br&gt;writable: 能否修改属性的值， 默认值 true&lt;br&gt;value： 获取修改属性的值。 默认值 undifined&lt;br&gt;Object.defineProperty( 属性所在的对象， 需要修改的属性名， 描述符对象)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;访问器属性：&lt;/em&gt;&lt;br&gt;configurable: 能否通过 delete 删除属性从而重新定义属性，默认值 true&lt;br&gt;enumerable: 是否可以通过 forin 循环， 默认值 true&lt;br&gt;get: 获取属性值， 默认值 undifined&lt;br&gt;set：设置属性值。 默认值 undifined&lt;br&gt;访问器属性不能直接定义， 只能通过 Object.defineProperty 来定义&lt;br&gt;Object.defineProperties(target， {})&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript语法</title>
    <link href="http://zhangliminabc.github.io/ecmescript%E8%AF%AD%E6%B3%95/"/>
    <id>http://zhangliminabc.github.io/ecmescript%E8%AF%AD%E6%B3%95/</id>
    <published>2021-04-19T08:27:57.000Z</published>
    <updated>2021-04-19T08:27:57.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>if语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * if (condition) statement1 esle statement2</span></span><br><span class="line"><span class="comment"> *  condition: 可以为任意的表达式，而且对这个值的求职结果不一定是布尔值。js自动会对condition的值调用boolean方法去转* 为布尔值</span></span><br><span class="line"><span class="comment"> * 如果condition为true就在执行statement1, 否则就执行statement2语句。这个两个语句可以是一句代码，也可以是个代码块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">25</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fyrgfyr&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>do-while 语句: 是一种后测试语句(只有在循环体的中的代码执行完之后才会测试出口条件, 循环体至少执行一次)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * do&#123;statement&#125; whild(expressiong)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &gt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p>while 语句: 前测试循环语句(循环体可一次都不执行)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  while(expression) statement</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"> <span class="function"><span class="title">while</span>(<span class="params"> i&lt; = <span class="number">10</span> </span>)</span> &#123;</span><br><span class="line">   i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>for 语句: 前测试循环语句（有执行循环之前初始化变量和定义循环后要执行的代码的能力）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for(initalnition; expressiong; loop-expressiong) statement</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>forin 语句: 是一种精准的迭代语句，用来枚举对象的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for(property in expression) statement</span></span><br><span class="line"><span class="keyword">for</span> (pro <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pro);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>break 和 continue 语句: 用于在循环中精确的控制代码的执行</p><ul><li>break: 会立即退出循环, 强制执行循环语句后面的语句</li><li>countinue: 会立即退出循环, 但是退出循环之后会从循环的顶部立即执行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li><li><p>switch 语句: 在比较时是采用全等操作符，因此不会发生类型装换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果表达式等于这个值，则执行后面的语句</span></span><br><span class="line"><span class="comment">* switch(express)</span></span><br><span class="line"><span class="comment">* case value: statement</span></span><br><span class="line"><span class="comment">*   break;</span></span><br><span class="line"><span class="comment">* case value: statement</span></span><br><span class="line"><span class="comment">*   break;</span></span><br><span class="line"><span class="comment">* default: statement</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;if语句&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
      <category term="ECMAScript" scheme="http://zhangliminabc.github.io/categories/ecmascript/"/>
    
    
      <category term="ECMAScript" scheme="http://zhangliminabc.github.io/tags/ecmascript/"/>
    
  </entry>
  
</feed>
