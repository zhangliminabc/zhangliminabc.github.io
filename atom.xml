<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅笑整个夏季</title>
  
  <subtitle>做一个快乐的程序媛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangliminabc.github.io/"/>
  <updated>2021-07-05T11:53:24.000Z</updated>
  <id>http://zhangliminabc.github.io/</id>
  
  <author>
    <name>浅笑整个夏季</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>css重学(1)-单位</title>
    <link href="http://zhangliminabc.github.io/style-07-05-css%E9%87%8D%E5%AD%A6-1-%E5%8D%95%E4%BD%8D/"/>
    <id>http://zhangliminabc.github.io/style-07-05-css%E9%87%8D%E5%AD%A6-1-%E5%8D%95%E4%BD%8D/</id>
    <published>2021-07-05T11:53:24.000Z</published>
    <updated>2021-07-05T11:53:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="css中的常用单位："><a href="#css中的常用单位：" class="headerlink" title="css中的常用单位："></a>css中的常用单位：</h4><p>设备像素： 设备屏幕实际拥有的像素点； 一般来说： 宽度方向有1920个像素点，长度方向有1080个像素点</p><p>逻辑像素： CSS的像素单位（css的px）其尺寸大小是想相对的， 也称谓独立像素</p><p>分辨率： 屏长的设备像素 * 屏宽的设备像素（1920 * 1080 )</p><p>ppi(pixels per inch): 像素密度，便是沿对角线没英寸长度的像素数目，越大显示的越细腻</p><p>缩放因子： 逻辑像素相对于设备像素的放大比例， 可通过window.devicePixelRatio获得</p><p>分辨率（设备像素） = 设备尺寸 * 像素密度</p><p>关系一：<br>  设备尺寸 × 像素密度 = 分辨率（设备像素）</p><p>举例：<br>  iphone6s 对角线长度为5.5 inches，像素密度401 ppi，分辨率 1920 * 1080，计算可得对角线的设备像素为2205.5。<br>  5.5 * 401 = 2205.5</p><p>关系二：<br>  逻辑像素(css的px) = 设备像素 × 缩放因子</p><p>举例：<br>  iphone6逻辑像素为375 * 667，分辨率为750 * 1334，缩放因子为2<br>  1个逻辑像素（1px） = 设备宽度的1/375<br>  1个设备像素 = 设备宽度的1/750</p><p>px: 独立像素</p><p>em: 根据父元素的字体大小来计算字体大小</p><p>rem: 相对于根元素html字体大小计算字体大小</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> docEl = win.document.documentElement;</span><br><span class="line"><span class="keyword">const</span> resiezeEvt = <span class="string">&#x27;orientationchange&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> refreshRem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> clientWidth = win.innerWidth || doc.documentElement.clientWidth || doc.body.clientWidth;</span><br><span class="line">   <span class="built_in">console</span>.log(clientWidth)</span><br><span class="line">   <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">let</span> fz;</span><br><span class="line">   <span class="keyword">const</span> width = clientWidth;</span><br><span class="line">   fz = <span class="number">16</span> * width / <span class="number">375</span>;</span><br><span class="line">   docEl.style.fontSize = fz + <span class="string">&#x27;px&#x27;</span>;<span class="comment">//这样每一份也是16px,即1rem=16px</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span><br><span class="line"> win.addEventListener(resizeEvt, refreshRem, <span class="literal">false</span>);</span><br><span class="line"> doc.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, refreshRem, <span class="literal">false</span>);</span><br><span class="line"> refreshRem();</span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;css中的常用单位：&quot;&gt;&lt;a href=&quot;#css中的常用单位：&quot; class=&quot;headerlink&quot; title=&quot;css中的常用单位：&quot;&gt;&lt;/a&gt;css中的常用单位：&lt;/h4&gt;&lt;p&gt;设备像素： 设备屏幕实际拥有的像素点； 一般来说： 宽度方向有1920个像素
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://zhangliminabc.github.io/categories/css/"/>
    
    
      <category term="CSS" scheme="http://zhangliminabc.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>重学js值(3)-super</title>
    <link href="http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E5%80%BC-3-super/"/>
    <id>http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E5%80%BC-3-super/</id>
    <published>2021-07-02T08:56:08.000Z</published>
    <updated>2021-07-02T08:56:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="super-用于访问和调用一个对象的父对象上的函数"><a href="#super-用于访问和调用一个对象的父对象上的函数" class="headerlink" title="super: 用于访问和调用一个对象的父对象上的函数"></a>super: 用于访问和调用一个对象的父对象上的函数</h4><h5 id="Object-getPrototypeOf-Object-setPrototypeOf-返回的是对象的隐士的原型对象-proto"><a href="#Object-getPrototypeOf-Object-setPrototypeOf-返回的是对象的隐士的原型对象-proto" class="headerlink" title="Object.getPrototypeOf / Object.setPrototypeOf: 返回的是对象的隐士的原型对象 proto"></a>Object.getPrototypeOf / Object.setPrototypeOf: 返回的是对象的隐士的原型对象 <strong>proto</strong></h5><h5 id="Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"><a href="#Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。" class="headerlink" title="Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"></a>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</h5><h4 id="babel编译super"><a href="#babel编译super" class="headerlink" title="babel编译super"></a>babel编译super</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">_getPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf ?</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf :</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(o);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> _getPrototypeOf(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_assertThisInitialized</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (self === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">&quot;this hasn&#x27;t been initialised - super() hasn&#x27;t been called&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (call &amp;&amp; (_typeof(call) === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> call === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperMethod</span>(<span class="params">subClass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="function"><span class="keyword">function</span>  <span class="title">_createSuperInternal</span>(<span class="params">subClass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 这两步参考extends</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">super</span> = _getPrototypeOf(subClass)</span><br><span class="line"><span class="keyword">const</span> newTarget =  _getPrototypeOf(<span class="built_in">this</span>).constructor</span><br><span class="line"><span class="comment">/** Reflect.constructor(super, constructor, newTarget) 相当于 =  </span></span><br><span class="line"><span class="comment">var obj2 = Object.create(newTarget.prototype);</span></span><br><span class="line"><span class="comment">super.apply(obj2, args);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">result = <span class="built_in">Reflect</span>.constructor(<span class="built_in">super</span>, <span class="built_in">arguments</span>, newTarget)</span><br><span class="line"><span class="keyword">return</span> _possibleConstructorReturn(<span class="built_in">this</span>, result) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;super-用于访问和调用一个对象的父对象上的函数&quot;&gt;&lt;a href=&quot;#super-用于访问和调用一个对象的父对象上的函数&quot; class=&quot;headerlink&quot; title=&quot;super: 用于访问和调用一个对象的父对象上的函数&quot;&gt;&lt;/a&gt;super: 用于访
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>重学js值(2)-extends</title>
    <link href="http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E5%80%BC(2)-extends/"/>
    <id>http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E5%80%BC(2)-extends/</id>
    <published>2021-07-02T04:11:58.000Z</published>
    <updated>2021-07-02T04:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"><a href="#Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。" class="headerlink" title="Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"></a>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</h5><h4 id="先搞定清楚-prototype-和-proto之间的区别"><a href="#先搞定清楚-prototype-和-proto之间的区别" class="headerlink" title="先搞定清楚 prototype 和 proto之间的区别"></a>先搞定清楚 prototype 和 <strong>proto</strong>之间的区别</h4><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><pre><code>a, 拥有属性的对象不同</code></pre><p><strong>proto</strong>: 在js中， 万物皆为对象，对象具有<strong>proto</strong>属性，可称为隐式原型； 一个对象的隐式原型指向该对象的构造函数的原型（js的对象）</p><p>prototype: 函数这个特殊对象所特有的属性（原型属性）（函数）</p><pre><code>b,  指向不同</code></pre><p>1，<strong>proto</strong> 指向它的构造函数的原型对象（prototype ）</p><p>2，该原型对象也有一个自己的隐式原型( <strong>proto</strong> ) 和 constructor;<br>    constructor: 指向构造函数<br>    <strong>proto</strong>: 指向它的构造函数的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Test.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">Test.prototype.constructor === Test <span class="comment">// true</span></span><br><span class="line">Test.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="extends做了什么？？"><a href="#extends做了什么？？" class="headerlink" title="extends做了什么？？"></a>extends做了什么？？</h4><pre><code>extends在实现继承方面，本质上也是原型链继承,该方法实现了两步原型链继承    1）子类的__proto__属性，表示构造函数的继承，总是指向父类。（把子类构造函数(Child)的原型(__proto__)指向了父类构造函数(Parent)）    2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</code></pre><h4 id="自定义实现extends"><a href="#自定义实现extends" class="headerlink" title="自定义实现extends"></a>自定义实现extends</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">customExtends</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 创建以constructor对象为基准的__proto__ == superClass.prototype</span></span><br><span class="line">subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">      <span class="title">constructor</span>: &#123; </span><br><span class="line">value: subClass,</span><br><span class="line">writable: <span class="literal">true</span>,</span><br><span class="line">configurable: <span class="literal">true</span> </span><br><span class="line">&#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 2. 将子类的隐式原型设置为父类</span></span><br><span class="line">subClass.__proto__ = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="babel编译extends"><a href="#babel编译extends" class="headerlink" title="babel编译extends"></a>babel编译extends</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">&#x27;function&#x27;</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Super expression must either be null or a function &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line"><span class="title">constructor</span>: &#123;</span><br><span class="line">value: subClass,</span><br><span class="line">writable: <span class="literal">true</span>,</span><br><span class="line">configureable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> (superClass) &#123;</span><br><span class="line">_setPrototypeOf(subClass, superClass)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">_setPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf || <span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123; o.__proto__ = p; <span class="keyword">return</span> o&#125;</span><br><span class="line"><span class="comment">// subClass.__proto__ = superClass</span></span><br><span class="line"><span class="keyword">return</span> _setPrototypeOf(subClass, superClass)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。&quot;&gt;&lt;a href=&quot;#Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="JavaScriptj" scheme="http://zhangliminabc.github.io/categories/javascriptj/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>重学js之(1)-new</title>
    <link href="http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B(1)-new/"/>
    <id>http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B(1)-new/</id>
    <published>2021-07-01T12:21:21.000Z</published>
    <updated>2021-07-01T12:21:21.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="new的作用"><a href="#new的作用" class="headerlink" title="new的作用"></a>new的作用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Test(<span class="string">&#x27;测试&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance.name) <span class="comment">// 测试</span></span><br><span class="line"></span><br><span class="line">instance.setName(<span class="string">&#x27;测试1&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance.name) <span class="comment">// 测试1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p> new 通过构造函数创建出来的实例可以访问构造函数中的属性</p><p> new 通过构造函数创建出来的实例可以访问原型链中的属性和方法； 也就是说通过new操作符实例和构造函数通过原型链连接起来了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">age</span>: <span class="number">24</span>&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Test(<span class="string">&#x27;yck&#x27;</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(t) <span class="comment">// &#123; age: 26 &#125;</span></span><br><span class="line">   <span class="built_in">console</span>.log(t.name) <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><p> 构造函数如果返回值为对象，那么这个返回值会被正常使用 </p><h6 id="自定义实现-new-操作符"><a href="#自定义实现-new-操作符" class="headerlink" title="自定义实现 new 操作符"></a>自定义实现 new 操作符</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNew</span>(<span class="params">Con, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">// 解释了static类型的方法不能通过this调用的原因</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, Con.prototype)</span><br><span class="line"><span class="comment">// apply方法调用一个具有给定this值的函数</span></span><br><span class="line"><span class="keyword">let</span> result = Con.apply(<span class="built_in">this</span>, args)</span><br><span class="line"><span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;new的作用&quot;&gt;&lt;a href=&quot;#new的作用&quot; class=&quot;headerlink&quot; title=&quot;new的作用&quot;&gt;&lt;/a&gt;new的作用&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>es深入浅出系列(2)</title>
    <link href="http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-2/"/>
    <id>http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-2/</id>
    <published>2021-06-09T13:22:41.000Z</published>
    <updated>2021-06-09T13:22:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>ES6 允许写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>解构赋值允许指定默认值。</p><p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [firstItem = []] = []</span><br><span class="line"></span><br><span class="line">firstItem <span class="comment">// []; 解构赋值在解构出来的值为undefined时，默认值才会生效</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;解构&quot;&gt;&lt;a href=&quot;#解构&quot; class=&quot;headerlink&quot; title=&quot;解构&quot;&gt;&lt;/a&gt;解构&lt;/h3&gt;&lt;p&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。&lt;/p&gt;
&lt;p&gt;以前，为变量赋值
      
    
    </summary>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/categories/ecmascript/"/>
    
      <category term="javascript" scheme="http://zhangliminabc.github.io/categories/ecmascript/javascript/"/>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>es深入浅出系列(1)</title>
    <link href="http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-1/"/>
    <id>http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-1/</id>
    <published>2021-06-09T12:45:56.000Z</published>
    <updated>2021-06-09T12:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="let和const系列"><a href="#let和const系列" class="headerlink" title="let和const系列"></a>let和const系列</h4><h3 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not undefined</span></span><br><span class="line">b <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p>  const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const PI &#x3D; 3.1415</span><br><span class="line"></span><br><span class="line">PI &#x2F;&#x2F; 3.1415</span><br><span class="line"></span><br><span class="line">pI &#x3D; 3 &#x2F;&#x2F; TypeError: Assignment to constant variable</span><br></pre></td></tr></table></figure><p>const语法对于引用类型是可以更改和增加其属性值， 因为对于引用类型在内存中存储的是一个引用地址； 对于const命令不能将引用地址更改</p><p>1, let 和 const 的出现解决了什么问题？</p><pre><code>在es5中只有全局作用域和函数作用域，带来很多不合理的场景第一种场景： 内层变量覆盖外层变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;这不是时间&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 这不是时间， 原因在于用var 声明的变量存在变量提升， 导致函数执行时在当前函数作用域中就能找到对应的a变量因此进行了输出</span></span><br></pre></td></tr></table></figure>第二中场景： 变量泄露为全局变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= s.length-<span class="number">1</span>; i++</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 5; 原因在于 变量i用var 声明， 导致循环执行结束之后，变量i并没有销毁, 泄露成了全局变量</span></span><br></pre></td></tr></table></figure></code></pre><p>2, let 和const的共同点<br>    1, 没有变量提升<br>    2, 增加了块级作用域<br>    3, 必须先定义后使用, 都存在暂时性死区(在代码块内，使用<code>let</code>和 <code>const</code>命令声明变量之前，该变量都是不可用的变)<br>    4, 在同一个块级作用域中不能重复定义相同的变量</p><p>注意点：</p><ul><li>允许在块级作用域中声明函数</li><li>函数声明类似于 ‘var’，即会提升到全局作用域或者函数作用域的头部（var的变量声明）</li><li>函数声明还会提升到所在的块级作用域的头部</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>相当于运行以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;let和const系列&quot;&gt;&lt;a href=&quot;#let和const系列&quot; class=&quot;headerlink&quot; title=&quot;let和const系列&quot;&gt;&lt;/a&gt;let和const系列&lt;/h4&gt;&lt;h3 id=&quot;let-命令&quot;&gt;&lt;a href=&quot;#let-命令&quot; cla
      
    
    </summary>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/categories/ecmascript/"/>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>webrtc基础概念介绍</title>
    <link href="http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D/"/>
    <id>http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-06-07T11:55:07.000Z</published>
    <updated>2021-06-07T11:55:07.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="webrtc" scheme="http://zhangliminabc.github.io/categories/webrtc/"/>
    
    
      <category term="webrtc" scheme="http://zhangliminabc.github.io/tags/webrtc/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D-2/"/>
    <id>http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D-2/</id>
    <published>2021-06-07T11:53:19.675Z</published>
    <updated>2021-06-07T11:53:19.675Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>nodejs介绍</title>
    <link href="http://zhangliminabc.github.io/nodejs-05-31-nodejs%E4%BB%8B%E7%BB%8D-2/"/>
    <id>http://zhangliminabc.github.io/nodejs-05-31-nodejs%E4%BB%8B%E7%BB%8D-2/</id>
    <published>2021-05-31T08:25:32.000Z</published>
    <updated>2021-05-31T08:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript: 定义了语法（本身只有语法和词法， 简称语法); 比如: 变量定义、循环、判断、函数、原型、原型链、作用域、闭包、异步<br>(ES教程)[<a href="https://es6.ruanyifeng.com/]">https://es6.ruanyifeng.com/]</a></p><p>javascript:  是用ES语法规范 + web API; 两者结合，即可完成浏览器端的任何操作<br>    web Api: BOM、DOM、事件绑定、Ajax、 websock等</p><p>nodejs: 使用ES语法规范 + nodejs api；</p>]]></content>
    
    <summary type="html">
    
      ECMAScript、javascript、nodejs的区别
    
    </summary>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/categories/nodejs/"/>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>nvm控制node版本</title>
    <link href="http://zhangliminabc.github.io/nodejs-05-31-nvm%E6%8E%A7%E5%88%B6node%E7%89%88%E6%9C%AC-1/"/>
    <id>http://zhangliminabc.github.io/nodejs-05-31-nvm%E6%8E%A7%E5%88%B6node%E7%89%88%E6%9C%AC-1/</id>
    <published>2021-05-31T08:19:58.000Z</published>
    <updated>2021-05-31T08:19:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>nvm 控制node 版本</p><p>nvm:  (github地址)[<a href="https://github.com/nvm-sh/nvm]">https://github.com/nvm-sh/nvm]</a></p><p>commender list:</p><ul><li>nvm list</li><li>nvm use</li><li>nvm install</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nvm 控制node 版本&lt;/p&gt;
&lt;p&gt;nvm:  (github地址)[&lt;a href=&quot;https://github.com/nvm-sh/nvm]&quot;&gt;https://github.com/nvm-sh/nvm]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;commender list:&lt;
      
    
    </summary>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/categories/nodejs/"/>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>面试题css(1)</title>
    <link href="http://zhangliminabc.github.io/interview-css-05-26-%E9%9D%A2%E8%AF%95%E9%A2%98css-1/"/>
    <id>http://zhangliminabc.github.io/interview-css-05-26-%E9%9D%A2%E8%AF%95%E9%A2%98css-1/</id>
    <published>2021-05-26T13:03:26.000Z</published>
    <updated>2021-05-26T13:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>常见的css属性  <a href="https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/common-use-css-property.html">常见的属性</a></p></li><li><p>css 盒模型 <a href="https://css.doyoe.com/">盒模型</a></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标准盒模型： width &#x3D; content</span><br><span class="line">ie盒模型： width &#x3D; content + padding + border</span><br><span class="line">不同的浏览器渲染默认对盒模型的渲染是不同的</span><br><span class="line">box-sizing: </span><br></pre></td></tr></table></figure></li><li><p>文档流</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从上到下，从左到右</span><br></pre></td></tr></table></figure></li><li><p>display取值</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. block    独占一行， 可设置宽高内外边距， 默认宽度由父容器决定，默认高度有内容决定</span><br><span class="line">2. inline-block  不独占一行</span><br><span class="line">3. inline 宽度和高度都有内容决定，与其他元素共占一行。</span><br><span class="line">4. table-call</span><br><span class="line">5. none</span><br><span class="line">6. flex 弹性盒不 </span><br></pre></td></tr></table></figure></li><li><p>css 定位</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">relative:  相对不自己本身</span><br><span class="line">absolute: 相对于不是static定位的父级元素</span><br><span class="line">fixed: 相对于可视窗口</span><br><span class="line">static: 默认的</span><br></pre></td></tr></table></figure></li><li><p>css浮动 <a href="http://www.iyunlu.com/view/css-xhtml/55.html">清除浮动</a></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 在浮动元素后添加额外的标签设置为 clear： both</span><br><span class="line">2. 父元素设置： overflow： hidden</span><br><span class="line">3. 使用 after伪类： content:&quot;.&quot;; display:block; height:0; visibility:hidden; clear:both;</span><br></pre></td></tr></table></figure></li></ol><p>5.css选择器<a href="https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css-selector.html">选择器和权重</a></p><p>6.css权重 <a href="http://www.w3cplus.com/css/css-specificity-things-you-should-know.html">权重</a></p><pre><code>从0开始，一个行内样式+1000，一个id+100，一个属性选择器/class或者伪类+10，一个元素名，或者伪元素+1</code></pre><p>7.css书写规范 <a href="http://www.shejidaren.com/css-written-specifications.html">规范</a></p><p>8.flexbox 和 网格布局</p><p>9.请写出如何垂直水平居中div</p><pre><code>分为已知宽高和未知宽高</code></pre><p>10.请简述css3有哪些新特性？</p><pre><code>border-radius,  text-shadow, transform, gradient</code></pre>]]></content>
    
    <summary type="html">
    
      介绍常见的css属性和css的盒模型，解释了display相关取值的区别....等; 汇聚了css相关的面试常考察点
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="CSS编程" scheme="http://zhangliminabc.github.io/categories/interview/css%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>HTML编程系列(1)</title>
    <link href="http://zhangliminabc.github.io/interview-html-05-26-%E9%9D%A2%E8%AF%95%E9%A2%98html-1/"/>
    <id>http://zhangliminabc.github.io/interview-html-05-26-%E9%9D%A2%E8%AF%95%E9%A2%98html-1/</id>
    <published>2021-05-26T12:55:34.000Z</published>
    <updated>2021-05-26T12:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>简述一下你对HTML语义化的理解</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 用正确的标签做正确的事， </span><br><span class="line">2. 有利于搜索引擎的搜索，</span><br><span class="line">3. 有利于阅读源代码或者开发人员更容易将网站分块和阅读</span><br></pre></td></tr></table></figure></li><li><p>请写出行内元素? 块级元素， 空元素有哪些？</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.行内元素： span,  a,  b,  img,  input, select,strong</span><br><span class="line">2.块级元素： div, ol,li,h1-h6,p, ul,table</span><br><span class="line">3. 空元素：br,hr,img, input, link, meta</span><br></pre></td></tr></table></figure></li><li><p>HTML5的form如何关闭自动完成功能？</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不需要提示的form或者某个input设置属性为：  autocomplete&#x3D;off</span><br></pre></td></tr></table></figure></li><li><p>html5有哪些新特性？</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 新增 画板元素 canvas, </span><br><span class="line">2. 视频音频： video, audio,</span><br><span class="line">3. 语义化的标签 header, footer, nav, section, article, calendar(日历), date(日期)， time, email, url, search, </span><br><span class="line">4. 地理定位： Geolocation ( 浏览器对象 navigator)</span><br><span class="line">navigator.geolocation.getCurrentPosition</span><br><span class="line">5. 网络： websocket， webworker （向服务器发送事件）</span><br></pre></td></tr></table></figure></li><li><p>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</p></li><li><p>doctype是什么,举例常见doctype及特点</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">doctype: 文档类型</span><br><span class="line">浏览器渲染模式：</span><br><span class="line">非怪异（标准）模式</span><br><span class="line">怪异模式</span><br><span class="line">部分怪异（近乎标准）模式</span><br><span class="line">1. HTML 4.01 strict doctype 适用于验证文档是否符合 HTML 4.01 规范</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;strict.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">2. HTML 4.01 transitional doctype</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">3. HTML 4.01 frameset doctype</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">4. XML 1.0 strict doctype</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Strict&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-strict.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">5. XML 1.0 transitional doctype</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">6. XML 1.0 frameset doctype</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">html 与 xhtml : </span><br><span class="line">html大小写不敏感， xhtml： 元素和属性名大小写敏感，且一律为小写</span><br><span class="line">html： 空元素可以不关闭标签，  xhtml： 每个元素都需要闭合。如果元素内容为空，则需要自闭合</span><br><span class="line">html： 允许使用缩写属性， xhtml： 不允许使用缩写属性，每个属性都需要声明属性名与属性值</span><br></pre></td></tr></table></figure></li><li><p>meta 标签</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. X-UA-Compatible是IE 浏览器一个专有&lt;meta&gt;属性，它告诉IE采用何种IE版本去渲染网页 </span><br><span class="line"> &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot; &#x2F;&gt;</span><br><span class="line">2. content  设置或返回 &lt;meta&gt; 元素的 content 属性的值</span><br><span class="line">3. name 把 content 属性连接到某个名称。</span><br><span class="line">4. scheme 设置或返回用于解释 content 属性的值的格式</span><br><span class="line">5. httpEquiv： 把 content 属性连接到一个 HTTP 头部。</span><br><span class="line"></span><br><span class="line">[ref](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000004279791)</span><br></pre></td></tr></table></figure></li><li><p>浏览器的重绘和回退？</p><pre><code>重绘： 不影响它周围或内部布局的属性， 只是修改元素本身的颜色，文字颜色等回退： 影响它周围或内部布局的属性</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      1,简述一下你对HTML语义化的理解; 2,请写出行内元素? 块级元素， 空元素有哪些？;  3,HTML5的form如何关闭自动完成功能？;.....等，汇聚了HTML相关的面试题和HTML的相关知识点
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="HTML" scheme="http://zhangliminabc.github.io/categories/interview/html/"/>
    
    
      <category term="HTML" scheme="http://zhangliminabc.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>javascript编程系列(5)</title>
    <link href="http://zhangliminabc.github.io/interview-05-14-%E9%9D%A2%E8%AF%95%E9%A2%98js-5/"/>
    <id>http://zhangliminabc.github.io/interview-05-14-%E9%9D%A2%E8%AF%95%E9%A2%98js-5/</id>
    <published>2021-05-14T09:45:41.000Z</published>
    <updated>2021-05-14T09:45:41.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="js编程题" scheme="http://zhangliminabc.github.io/categories/interview/js%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>javascript编程系列(4)</title>
    <link href="http://zhangliminabc.github.io/interview-05-12-%E9%9D%A2%E8%AF%95%E9%A2%98js-4/"/>
    <id>http://zhangliminabc.github.io/interview-05-12-%E9%9D%A2%E8%AF%95%E9%A2%98js-4/</id>
    <published>2021-05-12T02:48:54.000Z</published>
    <updated>2021-05-12T02:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>在一堆正整数中， 找到最长的一组斐波拉契烈段</p><p>  <a href="../../code/findFibonacci.js">源码</a></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFibonacci</span>(<span class="params">inputArr</span>) </span>&#123;</span><br><span class="line">    inputArr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">let</span> startIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> item = []</span><br><span class="line">    <span class="keyword">let</span> current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> lastValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> endIndex = inputArr.length</span><br><span class="line">    <span class="keyword">const</span> numberMap = inputArr.reduce(<span class="function">(<span class="params">pre, num, index</span>) =&gt;</span> &#123;</span><br><span class="line">        pre[num] = index</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isFibona = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = current + next</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> numberMap[value] !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                item.push(current)</span><br><span class="line">            &#125; </span><br><span class="line">            item.push(next)</span><br><span class="line">            current = next</span><br><span class="line">            next = value</span><br><span class="line">            lastValue = value</span><br><span class="line">            <span class="keyword">return</span> numberMap[value]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params">startIndex &lt; endIndex</span>)</span> &#123;</span><br><span class="line">        current = inputArr[startIndex]</span><br><span class="line">        next = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (item.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">        item = []</span><br><span class="line">        <span class="keyword">let</span> nextIndex = startIndex + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = nextIndex; i &lt;= endIndex - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            next = inputArr[i]</span><br><span class="line">            <span class="keyword">const</span> index = isFibona()</span><br><span class="line">            <span class="keyword">if</span> (index) &#123;</span><br><span class="line">                i = index - <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        item.push(lastValue)</span><br><span class="line">        startIndex++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> data = result.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.length - b.length)</span><br><span class="line">    <span class="keyword">return</span> data[data.length -<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputArr = [<span class="number">13</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">31</span>, <span class="number">11</span>, <span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findFibonacci(inputArr))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在一堆正整数中， 找到最长的一组斐波拉契烈段
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="js编程题" scheme="http://zhangliminabc.github.io/categories/interview/js%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>javascript编程系列(3)</title>
    <link href="http://zhangliminabc.github.io/interview-05-11-%E9%9D%A2%E8%AF%95%E9%A2%98js-3/"/>
    <id>http://zhangliminabc.github.io/interview-05-11-%E9%9D%A2%E8%AF%95%E9%A2%98js-3/</id>
    <published>2021-05-11T12:15:54.000Z</published>
    <updated>2021-05-11T12:15:54.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>实现一个arrange函数， 可以实现和工作的调度</li></ul>]]></content>
    
    <summary type="html">
    
      实现一个arrange函数， 可以实现和工作的调度
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="js编程题" scheme="http://zhangliminabc.github.io/categories/interview/js%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>javascript编程系列(2)</title>
    <link href="http://zhangliminabc.github.io/interview-05-11-%E9%9D%A2%E8%AF%95%E9%A2%98js-2/"/>
    <id>http://zhangliminabc.github.io/interview-05-11-%E9%9D%A2%E8%AF%95%E9%A2%98js-2/</id>
    <published>2021-05-11T02:23:18.000Z</published>
    <updated>2021-05-11T02:23:18.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>实现一个函数，可以将数组转化为树状数据结构<br> <a href="../../code/buildTreeByArray.js">源码</a></p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">buildTreeByArray</span>(<span class="params">arr1</span>) </span>&#123;    <span class="keyword">const</span> map = arr1.reduce(<span class="function">(<span class="params">pre, item</span>) =&gt;</span> &#123;        <span class="keyword">const</span> &#123; id &#125; = item        pre[id] = item        <span class="keyword">return</span> pre    &#125;, &#123;&#125;)    arr1.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;        <span class="keyword">const</span> &#123; parent_id &#125; = item        <span class="keyword">if</span> (parent_id !== <span class="number">0</span>) &#123;            map[parent_id].children ? map[parent_id].children.push(item) : map[parent_id].children = [item]        &#125;    &#125;)    <span class="keyword">return</span> arr1.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.parent_id === <span class="number">0</span>)&#125;</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      实现一个函数，可以将数组转化为树状数据结构
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="js编程题" scheme="http://zhangliminabc.github.io/categories/interview/js%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>javascript编程系列(1)</title>
    <link href="http://zhangliminabc.github.io/interview-05-10-%E9%9D%A2%E8%AF%95%E9%A2%98js-1/"/>
    <id>http://zhangliminabc.github.io/interview-05-10-%E9%9D%A2%E8%AF%95%E9%A2%98js-1/</id>
    <published>2021-05-10T13:07:57.000Z</published>
    <updated>2021-05-10T13:07:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>实现一个函数，可以对url中的query部分做拆解， 返回一个 key -&gt; value形式的对象<br>  <a href="../../code/querySearch.js">源代码</a></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">querySearch</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!url) <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// const queryParams = url.split(&#x27;?&#x27;)[1] </span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/(?&lt;=\?).*(?=#)/gmi</span></span><br><span class="line">    <span class="keyword">const</span> queryParamsStr = reg.exec(url)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (!queryParamsStr) <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> queryParamsStr.split(<span class="string">&#x27;&amp;&#x27;</span>).reduce(<span class="function">(<span class="params">pre, str</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> [key, value = <span class="string">&#x27;&#x27;</span>] = str.split(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">        key = key.trim()</span><br><span class="line">        value = value.trim()</span><br><span class="line">        pre[key] = value</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(querySearch(<span class="string">&#x27;http://sample.com/?a=1&amp;b=2&amp;c=xx&amp;d#hash&#x27;</span>)) <span class="comment">// &#123; a: &#x27;1&#x27;, b: &#x27;2&#x27;, c: &#x27;xx&#x27;, d: &#x27;&#x27; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      实现一个函数，可以对url中的query部分做拆解， 返回一个 key -&gt; value形式的对象
    
    </summary>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/categories/interview/"/>
    
      <category term="js编程题" scheme="http://zhangliminabc.github.io/categories/interview/js%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
    
      <category term="Interview" scheme="http://zhangliminabc.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出11(面向对象)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA11(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA11(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1)/</id>
    <published>2021-05-10T12:00:09.000Z</published>
    <updated>2021-05-10T12:00:09.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-对象属性"><a href="#1-对象属性" class="headerlink" title="1. 对象属性"></a>1. 对象属性</h4><p><em>数据属性:</em><br>configurable: 能否通过 delete 删除属性从而重新定义属性，默认值 true<br>enumerable: 是否可以通过 forin 循环， 默认值 true<br>writable: 能否修改属性的值， 默认值 true<br>value： 获取修改属性的值。 默认值 undifined<br>Object.defineProperty( 属性所在的对象， 需要修改的属性名， 描述符对象)</p><p><em>访问器属性：</em><br>configurable: 能否通过 delete 删除属性从而重新定义属性，默认值 true<br>enumerable: 是否可以通过 forin 循环， 默认值 true<br>get: 获取属性值， 默认值 undifined<br>set：设置属性值。 默认值 undifined<br>访问器属性不能直接定义， 只能通过 Object.defineProperty 来定义<br>Object.defineProperties(target， {})</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最新的定义访问器属性的方法</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  year: <span class="number">2004</span>,</span><br><span class="line">  editor: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._year;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._year = newValue + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.year); <span class="comment">//2006</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧版的定义访问器属性的方法</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  year: <span class="number">2004</span>,</span><br><span class="line">  editor: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">book.__defineGetter__(<span class="string">&quot;year&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.year;</span><br><span class="line">&#125;);</span><br><span class="line">book.__defineSetter__(<span class="string">&quot;year&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.year = newValue + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.year); <span class="comment">//2006</span></span><br></pre></td></tr></table></figure><h4 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2. 创建对象"></a>2. 创建对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.job = job;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;校长&quot;</span>, <span class="number">10</span>, <span class="string">&quot;softarea&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">20</span>, <span class="string">&quot;doctor&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;teacher&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;校长&quot;</span>, <span class="number">10</span>, <span class="string">&quot;softarea&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">20</span>, <span class="string">&quot;doctor&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor); <span class="comment">//Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isPrototypeOf： 验证对象之间是否存在关系</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//hasOwnProperty: 验证对象属性是存在于实例中还是原型中</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JavaScript深入浅出面向对象，剖析了js为什么说是面向对象，并从封装、继承、多态三方面来解释js的面向对象
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出10(原型链)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA10(%E5%8E%9F%E5%9E%8B%E9%93%BE)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA10(%E5%8E%9F%E5%9E%8B%E9%93%BE)/</id>
    <published>2021-05-08T07:45:28.000Z</published>
    <updated>2021-05-08T07:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="js-分为函数对象和普通对象"><a href="#js-分为函数对象和普通对象" class="headerlink" title="js 分为函数对象和普通对象"></a>js 分为函数对象和普通对象</h5><ul><li><b>每个对象都有<strong>proto</strong>属性，prototype 属性只有函数对象才有</b></li><li><b>属性<em>proto</em>是一个对象，有 constructor 和<em>proto</em>属性</b></li><li><b>原型对象 prototype 有一个默认的 constructor，记录是由那个构造函数创建的</b></li><li><b>实例(instance)都包含一个指向原型对象的内部指针(<strong>proto</strong>)</b></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment"> * &#123; getFatherValue: function,</span></span><br><span class="line"><span class="comment"> *   constructor: Father()&#123;&#125;,</span></span><br><span class="line"><span class="comment"> *   __proto__: Object</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则三： 原型对象prototype有一个默认的constructor，记录是由那个构造函数创建的</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype.constructor === Father); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">new</span> Father();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   constructor: Father()&#123;&#125;,</span></span><br><span class="line"><span class="comment"> *   __proto__: Object</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Father); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="js-查找规则"><a href="#js-查找规则" class="headerlink" title="js 查找规则"></a>js 查找规则</h5><ul><li><b>如果试图在对象或者实例上查找某个属性，回先从对象内部查找;</b></li><li><b>当查不到的时候，会在该对象的原型中去查找</b></li></ul><p><b style="color:red;">查找对象属性时形成的链式查找叫做原型链（实例和原型的关系）</b></p><h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><p>1, new 操作符内部做了什么</p>  <ul style="color: red;">    <li>创建一个空对象</li>    <li>将空对象的__proto__属性指向实例函数的原型对象(prototype)</li>    <li>使用call绑定函数内的this指向</li>    <li>返回空对象</li>  </ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createdNew</span>(<span class="params">fun1</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = fun1.prototype;</span><br><span class="line">  fun1.call(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="string">&quot;这是父类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = createdNew(Father);</span><br><span class="line"><span class="built_in">console</span>.log(instance1 <span class="keyword">instanceof</span> Father1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>2, 写一个继承函数</p><ul><li><p>组合继承</p><ul><li><p>问题：</p><p>调用了两次父类构造函数(一次为 Son 函数内， 一次为初始化子类实例时), 造成了不必要的消耗</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;black&quot;</span>];</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.sayColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.color.join(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = Parent.prototype;</span><br><span class="line"></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instanceSon = <span class="keyword">new</span> Son(<span class="string">&quot;zhanglimin&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链的查找是根据__proto__一层层向上查找</span></span><br><span class="line"><span class="built_in">console</span>.log(instanceSon.sayAge); <span class="comment">// Function</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype.sayAge); <span class="comment">// Function</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.age); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.sayColor); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li><p>原型继承: 借助原型可以基于已有的对象创建新对象</p><ul><li>问题:<br>对于引用类型的值在实例中数据共享</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  type: [<span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;black&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = object(person);</span><br><span class="line"><span class="built_in">console</span>.log(p1.type); <span class="comment">// [&quot;yellow&quot;, &quot;white&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line">p1.type.push(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = object(person);</span><br><span class="line"><span class="built_in">console</span>.log(p2.type); <span class="comment">// [&quot;yellow&quot;, &quot;white&quot;, &quot;black&quot;, test]</span></span><br></pre></td></tr></table></figure><ul><li>组合继承</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass, parentClass</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createdObjec</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个对象，使对象的__proto__ 指向需要继承的原型</span></span><br><span class="line">  <span class="keyword">const</span> prototype = createdObjec(parentClass.prototype);</span><br><span class="line">  <span class="comment">// constructor指向子类，因为js原型中的规则为constructor指向由谁创建</span></span><br><span class="line">  prototype.constructor = subClass;</span><br><span class="line">  <span class="comment">// 改变子类的原型对象的指向</span></span><br><span class="line">  subClass.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="string">&quot;这是父类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentClass.prototype.syaHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.b = <span class="string">&quot;这是子类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subClass.prototype.saySub = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extend(subClass, parentClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subInstance = <span class="keyword">new</span> subClass();</span><br><span class="line"><span class="built_in">console</span>.log(subInstance.syaHello); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(subInstance.saySub); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>3, 怎么理解原型链: 查找属性时会优先在当前的对象中查找，当查找不到的之后会在对于的原型上查找</p><h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h4><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call函数</a></p><h4 id="封装：属性和方法的封装"><a href="#封装：属性和方法的封装" class="headerlink" title="封装：属性和方法的封装"></a>封装：属性和方法的封装</h4><p>  1, 闭包<br>  2, 对象</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>原型式继承</li></ul><p>原型链实现继承的问题： 数据属性共享， 不能向父类传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型链</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;res&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">instance.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance.colors); <span class="comment">//[&quot;res&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//[&quot;res&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"><span class="comment">// instanceof: 确定实例和原型的关系</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1 <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>构造函数式继承</li></ul><p>问题: 不能继承父类原型链上的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;res&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubClass()</span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperClass) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.getColors()) <span class="comment">// TypeError: instance.getColors is not a function </span></span><br></pre></td></tr></table></figure><ul><li>组合继承</li></ul><p>父类函数执行两次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;block&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instan1 = <span class="keyword">new</span> SubClass(<span class="number">11</span>);</span><br><span class="line">instan1.colors.push(<span class="string">&#x27;test1&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instan1.colors); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27;, &#x27;test1&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instan2 = <span class="keyword">new</span> SubClass(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instan2.colors, <span class="string">&#x27;属性&#x27;</span>); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27; ] 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(instan2.getColors()); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>寄生式继承</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPropotype</span>(<span class="params">ParentClass</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  f.prototype = ParentClass;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ParentClass.prototype.setColors = <span class="function"><span class="keyword">function</span> (<span class="params">colorName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors.push(colorName);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ParentClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ParentClass.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Extends</span>(<span class="params">parent, sub</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = inheritPropotype(parent.prototype);</span><br><span class="line">  p.construcor = sub;</span><br><span class="line">  sub.prototype = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Extends(ParentClass, SubInstance);</span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubInstance();</span><br><span class="line">sub1.setColors(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.getColors());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sub2 = <span class="keyword">new</span> SubInstance();</span><br><span class="line">sub2.setColors(<span class="string">&#x27;block&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub2.getColors());</span><br></pre></td></tr></table></figure><h4 id="多态：-同一种方法多种调用方式"><a href="#多态：-同一种方法多种调用方式" class="headerlink" title="多态： 同一种方法多种调用方式"></a>多态： 同一种方法多种调用方式</h4><p>js中函数参数可以通过arguments获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Polymorphism</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> argsLen = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">if</span> (argsLen &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Polymorphism(<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js的原型链
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出9(闭包)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA9(%E9%97%AD%E5%8C%85)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA9(%E9%97%AD%E5%8C%85)/</id>
    <published>2021-05-08T07:40:19.000Z</published>
    <updated>2021-05-08T07:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><h6 id="js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法"><a href="#js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法" class="headerlink" title="js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法"></a>js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法</h6><h6 id="通俗的解释是函数返回函数，我的理解是"><a href="#通俗的解释是函数返回函数，我的理解是" class="headerlink" title="通俗的解释是函数返回函数，我的理解是"></a>通俗的解释是函数返回函数，我的理解是</h6><h6 id="闭包就是能够读取其他函数内部变量的函数。由于在-Javascript-语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”"><a href="#闭包就是能够读取其他函数内部变量的函数。由于在-Javascript-语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”" class="headerlink" title="闭包就是能够读取其他函数内部变量的函数。由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”"></a>闭包就是能够读取其他函数内部变量的函数。由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”</h6><p><b style="color:red;">所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</b></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;全局属性&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">&quot;这是对象中的值&quot;</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">// My Object</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法， 这就是闭包
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
