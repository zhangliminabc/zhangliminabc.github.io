<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅笑整个夏季</title>
  
  <subtitle>做一个快乐的程序媛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangliminabc.github.io/"/>
  <updated>2021-08-04T07:30:24.000Z</updated>
  <id>http://zhangliminabc.github.io/</id>
  
  <author>
    <name>浅笑整个夏季</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue源码解析(2)</title>
    <link href="http://zhangliminabc.github.io/vue-08-04-vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-2/"/>
    <id>http://zhangliminabc.github.io/vue-08-04-vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-2/</id>
    <published>2021-08-04T07:30:24.000Z</published>
    <updated>2021-08-04T07:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Vue数据响应原理"><a href="#Vue数据响应原理" class="headerlink" title="Vue数据响应原理"></a>Vue数据响应原理</h4><p>core/instance/state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">vm._watchers = [];</span><br><span class="line"><span class="keyword">const</span> opt = vm.$options</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opts.props) &#123;</span><br><span class="line">initProps(vm, opts.props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opts.methods) &#123;</span><br><span class="line">initMethods(vm, opts.methods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">initData(vm)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">observe( (vm._data = &#123;&#125;), <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opts.computed) &#123;</span><br><span class="line">initComputed(vm, opts.computed)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">initWatch(vvm, opts.watch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="先解析data的数据响应"><a href="#先解析data的数据响应" class="headerlink" title="先解析data的数据响应"></a>先解析data的数据响应</h5><p>core/instance/state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> data = vm.$options.data</span><br><span class="line"><span class="comment">// 为vm上添加 _data属性</span></span><br><span class="line">data = vm._data === <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> ? getData(data, vm) : data || &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断data 是否是一个普通的对象， 使用的是原型上的toString方法</span></span><br><span class="line"><span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">data = &#123;&#125;</span><br><span class="line">process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(<span class="string">&quot; data function should return an object&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line"><span class="keyword">const</span> props= vm.$options.props</span><br><span class="line"><span class="keyword">const</span> methods= vm.$options.methods</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = keys.length</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">while</span>(<span class="params">i--</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> key = keys[i]</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">warn(</span><br><span class="line"><span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,</span><br><span class="line">vm</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp;</span><br><span class="line">warn(</span><br><span class="line"><span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line"><span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">vm</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line"><span class="comment">// 为vm上添加对应的属性值，这就是为什么data中的数据为什么使用this能访问到的原因</span></span><br><span class="line">proxy(vm, <span class="string">`_data`</span>, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">observe(data, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Vue数据响应原理&quot;&gt;&lt;a href=&quot;#Vue数据响应原理&quot; class=&quot;headerlink&quot; title=&quot;Vue数据响应原理&quot;&gt;&lt;/a&gt;Vue数据响应原理&lt;/h4&gt;&lt;p&gt;core/instance/state&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://zhangliminabc.github.io/categories/vue/"/>
    
    
      <category term="Vue" scheme="http://zhangliminabc.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue源码解析(1)</title>
    <link href="http://zhangliminabc.github.io/vue-08-03-vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1/"/>
    <id>http://zhangliminabc.github.io/vue-08-03-vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1/</id>
    <published>2021-08-03T08:28:15.000Z</published>
    <updated>2021-08-03T08:28:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建Vue实例的两步"><a href="#创建Vue实例的两步" class="headerlink" title="创建Vue实例的两步"></a>创建Vue实例的两步</h2><h5 id="创建Vue实例只需要两步"><a href="#创建Vue实例只需要两步" class="headerlink" title="创建Vue实例只需要两步"></a>创建Vue实例只需要两步</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(options)</span><br></pre></td></tr></table></figure><h3 id="创建Vue类-为Vue构造函数上添加属性和方法，但是函数未执行"><a href="#创建Vue类-为Vue构造函数上添加属性和方法，但是函数未执行" class="headerlink" title="创建Vue类(为Vue构造函数上添加属性和方法，但是函数未执行)"></a>创建Vue类(为Vue构造函数上添加属性和方法，但是函数未执行)</h3><p>在导入Vue构造函数之前会生成一个Vue的构造函数</p><p>platforms/web/entry-runtime.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;./runtime/index&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><p>platforms/web/runtime</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * extend(to, _from)方法将_from对象上的属性添加到to对象中并返回to对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">extend(Vue.options.directives, platformDirectives)</span><br><span class="line">extend(Vue.options.components, platformComponents)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加__patch__ 方法</span></span><br><span class="line">Vue.prototype.__patch__ = isBrower ? patch : noop</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加mount方法</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">el: string | Element, </span></span></span><br><span class="line"><span class="function"><span class="params">hydrating ?: boolean</span>)</span>&#123;</span><br><span class="line">el = el &amp;&amp; isBrower ? query(el) : <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><p>core/index</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;./instance/index&#x27;</span></span><br><span class="line">initGlobalAPI(Vue)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>core/global-api</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 添加 set、delete、nextTick方法</span></span><br><span class="line">Vue.set = set</span><br><span class="line">Vue.delete = del</span><br><span class="line">Vue.nextTick = nextTick</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建空的options对象</span></span><br><span class="line">Vue.options = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ASSET_TYPES: component/ filer / directive</span></span><br><span class="line"><span class="comment">//  创建空的components、directives、filters容器</span></span><br><span class="line">ASSET_TYPES.forEach(<span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">Vue.options[type + <span class="string">&#x27;s&#x27;</span>]  = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化use,</span></span><br><span class="line">initUse(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 mixin</span></span><br><span class="line">initMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 extend</span></span><br><span class="line">initExtend(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始 filter、component、directive</span></span><br><span class="line">initAssetRegisters(Vue)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>instance/index : Vue构造函数， 在vue的构造函数中只调用了_init方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_EVN !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue) ) &#123;</span><br><span class="line">warn(<span class="string">&#x27;Vue is a constructor ans should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关键</span></span><br><span class="line"><span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Vue原型上添加 _init方法</span></span><br><span class="line">initMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 $data 、 $props、 $watch 、 $set 、 $delete 属性</span></span><br><span class="line">stateMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 $on、$emit、 $off 、 $once事件</span></span><br><span class="line">eventsMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 _update、 $foreceupdate、 $destory 方法</span></span><br><span class="line">liftcycleMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 $nextTick、 _render 函数</span></span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><p>总结： 至此，我们就构建出了一个 Vue 类，这个类上的方法都已经添加完毕; 总结一下，我们创建的Vue类都包含了哪些内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._init()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局config对象，我们几乎不会用到</span></span><br><span class="line">Vue.config = &#123;</span><br><span class="line">  keyCodes,</span><br><span class="line">  _lifecycleHooks: [<span class="string">&#x27;beforeCreate&#x27;</span>, <span class="string">&#x27;created&#x27;</span>, ...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的options配置，我们每个组件都会继承这个配置。</span></span><br><span class="line">Vue.options = &#123;</span><br><span class="line">  beforeCreate, <span class="comment">// 比如 vue-router 就会注册这个回调，因此会每一个组件继承</span></span><br><span class="line">  components, <span class="comment">// 前面提到了，默认组件有三个 `KeepAlive`,`transition`, `transitionGroup`，这里注册的组件就是全局组件，因为任何一个组件中不用声明就能用了。所以全局组件的原理就是这么简单</span></span><br><span class="line">  directives, <span class="comment">// 默认只有 `v-show` 和 `v-model`</span></span><br><span class="line">  filters <span class="comment">// 不推荐使用了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些全局方法</span></span><br><span class="line">Vue.use <span class="comment">// 注册插件</span></span><br><span class="line">Vue.component <span class="comment">// 注册组件</span></span><br><span class="line">Vue.directive <span class="comment">// 注册指令</span></span><br><span class="line">Vue.nextTick <span class="comment">//下一个tick执行函数</span></span><br><span class="line">Vue.set/<span class="keyword">delete</span> <span class="comment">// 数据的修改操作</span></span><br><span class="line">Vue.mixin <span class="comment">// 混入mixin用的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue.prototype 上有几种不同作用的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由initMixin 添加的 `_init` 方法，是Vue实例初始化的入口方法，会调用其他的功能初始话函数</span></span><br><span class="line">Vue.prototype._init</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由 initState 添加的三个用来进行数据操作的方法</span></span><br><span class="line">Vue.prototype.$data</span><br><span class="line">Vue.prototype.$props</span><br><span class="line">Vue.prototype.$watch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由initEvents添加的事件方法</span></span><br><span class="line">Vue.prototype.$on</span><br><span class="line">Vue.prototype.$off</span><br><span class="line">Vue.prototype.$one</span><br><span class="line">Vue.prototype.$emit</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由 lifecycle添加的生命周期相关的方法</span></span><br><span class="line">Vue.prototype._update</span><br><span class="line">Vue.prototype.$forceUpdate</span><br><span class="line">Vue.prototype.$destroy</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 platform 中添加的生命周期方法</span></span><br><span class="line">Vue.prototype.$mount</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由renderMixin添加的`$nextTick` 和 `_render` 以及一堆renderHelper</span></span><br><span class="line">Vue.prototype.$nextTick</span><br><span class="line">Vue.prototype._render</span><br><span class="line">Vue.prototype._b</span><br><span class="line">Vue.prototype._e</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Vue创建阶段：-通过-new-Vue创建Vue的实例；实例的创建，肯定是从构造函数开始的，然后会进行一系列的初始化操作，我们依次看一下创建过程都进行了什么初始化操作"><a href="#Vue创建阶段：-通过-new-Vue创建Vue的实例；实例的创建，肯定是从构造函数开始的，然后会进行一系列的初始化操作，我们依次看一下创建过程都进行了什么初始化操作" class="headerlink" title="Vue创建阶段： 通过 new Vue创建Vue的实例；实例的创建，肯定是从构造函数开始的，然后会进行一系列的初始化操作，我们依次看一下创建过程都进行了什么初始化操作"></a>Vue创建阶段： 通过 new Vue创建Vue的实例；实例的创建，肯定是从构造函数开始的，然后会进行一系列的初始化操作，我们依次看一下创建过程都进行了什么初始化操作</h4><p>core/instance/init.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue.prototype._init  = <span class="function"><span class="keyword">function</span> (<span class="params">options: object</span>) </span>&#123;</span><br><span class="line"><span class="comment">// vm是this的别名</span></span><br><span class="line"><span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">vm._uid = uid++</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> startTag, endTag;</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">starTag = <span class="string">`vue-perf-start: <span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">endTag = <span class="string">`vue-perf-end: <span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">mark(startTag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vm._isVue = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">initInternalComponent(vm, options)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">vm.$options = margeOptions(</span><br><span class="line">resolveConstructorOptions(vm.constructor),</span><br><span class="line">options || &#123;&#125;,</span><br><span class="line">vm</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">initProxy(vm)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">vm._renderProxy = vm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vm._self = vm</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 做了一些生命周期的初始化工作，初始化了很多变量</span></span><br><span class="line"><span class="comment"> * 最主要是设置了父子组件的引用关系，也就是设置了 </span></span><br><span class="line"><span class="comment"> * `$parent` 和 `$children`、 $root、 $refs、</span></span><br><span class="line"><span class="comment"> *  _watcher、 _inactive、 _directInactive、 </span></span><br><span class="line"><span class="comment"> * _isMounted、_isDestroyed、 _isBeingDestroyed</span></span><br><span class="line"><span class="comment"> * 的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">initLifecycle(vm)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册事件，注意这里注册的不是自己的，而是父组件的。因为很明显父组件的监听器才会注册到孩子身上</span></span><br><span class="line"><span class="comment"> * _events、_hasHookEvent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">initEvents(vm)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 做一些 render 的准备工作，比如处理父子继承关系等，并没有真的开始 render</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">initRender(vm)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行beforecreate事件</span></span><br><span class="line">callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从options中获取对应的inject值遍历处理</span></span><br><span class="line">initInjections(vm)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据校验( $options中的数据校验)</span></span><br><span class="line"><span class="comment"> * props、 method、 data、 computed、watch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">initState(vm)</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve provide after data/props</span></span><br><span class="line">initProvide(vm)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行created函数</span></span><br><span class="line">callHook(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果传入了el元素执行mountd方法</span></span><br><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">vm.$mount(vm.$options.el)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>vue的实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">router,</span><br><span class="line">store,</span><br><span class="line">i18n,</span><br><span class="line">render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建Vue实例的两步&quot;&gt;&lt;a href=&quot;#创建Vue实例的两步&quot; class=&quot;headerlink&quot; title=&quot;创建Vue实例的两步&quot;&gt;&lt;/a&gt;创建Vue实例的两步&lt;/h2&gt;&lt;h5 id=&quot;创建Vue实例只需要两步&quot;&gt;&lt;a href=&quot;#创建Vue实例只需
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://zhangliminabc.github.io/categories/vue/"/>
    
    
      <category term="Vue" scheme="http://zhangliminabc.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vuex源码分析</title>
    <link href="http://zhangliminabc.github.io/vue-07-12-vuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://zhangliminabc.github.io/vue-07-12-vuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-07-12T11:44:21.000Z</published>
    <updated>2021-07-12T11:44:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>先抛出问题<br>1， vuex是什么<br>2， vuex是如何实现注入的，为什么每个组件都能通过访问$store访问store<br>3， vuex是如何处理模块以及模块嵌套的<br>4， vuex是如何保证只能通过matation实现改变state数据的</p><p>先看看官网怎么定义vuex<br>    vuex是一个专为vue应用程序开发的状态管理模式；采用集中式存储管理应用的所有组件的状态</p><p>进行源码分析之前，先了解一下官方文档中提供的核心思想，它代表着整个vuex框架的运行流程</p><img align="center" src="../../static/vuex.png"><ul><li><p>Vue components: vue组件，负责接收用户操作等交互行为，执行dispatch方法触发对应的action</p></li><li><p>dispatch：操作行为触发方法，是唯一能执行action的方法。</p></li><li><p>actions: 操作行为处理模块， 负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发</p></li><li><p>commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</p></li><li><p>mutations：状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</p></li><li><p>state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</p></li><li><p>getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</p></li></ul><p>先分析store函数</p><p>1, 先分析构造函数中的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">options = &#123;&#125;</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (!Vue &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">install(<span class="built_in">window</span>.Vue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">store</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue.use实现：实际上会执行插件中的install方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">plugin: <span class="built_in">Function</span> | <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="keyword">if</span> (plugin.installed) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// additional parameters</span></span><br><span class="line"><span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">args.unshift(<span class="built_in">this</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 实际执行插件的install方法</span></span><br><span class="line">plugin.install.apply(plugin, args)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">&#125;</span><br><span class="line">plugin.installed = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>vuex初始化装载分析 </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (!Vue &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">install(<span class="built_in">window</span>.vue)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>判断若处于浏览器环境下且加载过Vue，则执行install方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断若处于浏览器环境下且加载过Vue，则执行install方法</span></span><br><span class="line">  <span class="keyword">if</span> (!Vue &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">    install(<span class="built_in">window</span>.Vue)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>install函数， 将Vue变量赋值为全局的_vue变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line"><span class="built_in">console</span>.error(</span><br><span class="line"><span class="string">&#x27;[vuex] already installed. Vue.use(Vuex) should be called only once.&#x27;</span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">Vue = _Vue</span><br><span class="line">applyMixin(Vue)</span><br><span class="line">&#125;</span><br><span class="line">applyMixin</span><br></pre></td></tr></table></figure><p>applyMixin函数, 判断vue版本，通过hook注入或者重写原型链上的_init方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> version = <span class="built_in">Number</span>(Vue.version.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> (version &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 其实就是对象的合并</span></span><br><span class="line">        Vue.mixin(&#123; <span class="attr">beforeCreate</span>: vuexInit &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// override init and inject vuex init procedure</span></span><br><span class="line">        <span class="comment">// for 1.x backwards compatibility.</span></span><br><span class="line">        <span class="comment">// 查找vue原型链上的init方法</span></span><br><span class="line">        <span class="keyword">const</span> _init = Vue.prototype._init</span><br><span class="line">        Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">            options.init = options.init ?</span><br><span class="line">                [vuexInit].concat(options.init) :</span><br><span class="line">                vuexInit</span><br><span class="line">            _init.call(<span class="built_in">this</span>, options)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Vuex init hook, injected into each instances init hooks list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">// 将初始化vue跟组件时传入的store设置到this对象上的$store属性上，子组件从起父组件引用$store属性，层次嵌套进行设置</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">vuexInit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> options = <span class="built_in">this</span>.$options</span><br><span class="line">            <span class="comment">// store injection</span></span><br><span class="line">        <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">            <span class="built_in">this</span>.$store = <span class="keyword">typeof</span> options.store === <span class="string">&#x27;function&#x27;</span> ?</span><br><span class="line">                options.store() :</span><br><span class="line">                options.store</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">            <span class="built_in">this</span>.$store = options.parent.$store</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;img align=”center” src=”../../vuex-store注入.png&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先抛出问题&lt;br&gt;1， vuex是什么&lt;br&gt;2， vuex是如何实现注入的，为什么每个组件都能通过访问$store访问store&lt;br&gt;3， vuex是如何处理模块以及模块嵌套的&lt;br&gt;4， vuex是如何保证只能通过matation实现改变state数据的&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="vuex" scheme="http://zhangliminabc.github.io/categories/vuex/"/>
    
      <category term="vue" scheme="http://zhangliminabc.github.io/categories/vuex/vue/"/>
    
    
      <category term="vuex" scheme="http://zhangliminabc.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出13(es5-generator)</title>
    <link href="http://zhangliminabc.github.io/ecmascript-07-06-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA13-es5-generator/"/>
    <id>http://zhangliminabc.github.io/ecmascript-07-06-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA13-es5-generator/</id>
    <published>2021-07-06T13:36:17.000Z</published>
    <updated>2021-07-06T13:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。<br>一是，<code>function</code>关键字与函数名之间有一个星号；<br>二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ending&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码一共调用了四次<code>next</code>方法。</p><p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p><p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><p>ES6 没有规定，<code>function</code>关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure><p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在<code>function</code>关键字后面。本书也采用这种写法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。&lt;/p&gt;
&lt;p&gt;Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。&lt;/p&gt;
&lt;p&gt;执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。&lt;/p&gt;
&lt;p&gt;形式上，Generator 函数是一个普通函数，但是有两个特征。&lt;br&gt;一是，&lt;code&gt;function&lt;/code&gt;关键字与函数名之间有一个星号；&lt;br&gt;二是，函数体内部使用&lt;code&gt;yield&lt;/code&gt;表达式，定义不同的内部状态（&lt;code&gt;yield&lt;/code&gt;在英语里的意思就是“产出”）。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>javascript深入浅出12(原型链)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA12-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA12-%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2021-07-06T11:43:59.000Z</published>
    <updated>2021-07-06T11:43:59.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="prototype-和-proto"><a href="#prototype-和-proto" class="headerlink" title="prototype 和  proto"></a>prototype 和  <strong>proto</strong></h4><ul><li>每个函数都要一个原型对象（prototype) ， 原型对象包含一个指向构造函数的的指针(constructor)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;prototype-和-proto&quot;&gt;&lt;a href=&quot;#prototype-和-proto&quot; class=&quot;headerlink&quot; title=&quot;prototype 和  proto&quot;&gt;&lt;/a&gt;prototype 和  &lt;strong&gt;proto&lt;/strong
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>重学算法(1)-栈</title>
    <link href="http://zhangliminabc.github.io/algorithm-07-06-%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95-1-%E6%A0%88/"/>
    <id>http://zhangliminabc.github.io/algorithm-07-06-%E9%87%8D%E5%AD%A6%E7%AE%97%E6%B3%95-1-%E6%A0%88/</id>
    <published>2021-07-06T06:04:07.000Z</published>
    <updated>2021-07-06T06:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h4 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h4><p>后进者先出，先进者后出，简称 后进先出（LIFO） </p>1, 新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。2, 在栈里，新元素都靠近栈顶，旧元素都接近栈底。3, 从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。4, 不包含任何元素的栈称为空栈。]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h4&gt;&lt;h4 id=&quot;什么是栈&quot;&gt;&lt;a href=&quot;#什么是栈&quot; class=&quot;headerlink&quot; title=&quot;什么是栈&quot;&gt;&lt;/a&gt;什么是栈&lt;/h4&gt;&lt;p
      
    
    </summary>
    
    
      <category term="algorithm" scheme="http://zhangliminabc.github.io/categories/algorithm/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
      <category term="algorithm" scheme="http://zhangliminabc.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>css重学(1)-单位</title>
    <link href="http://zhangliminabc.github.io/style-07-05-css%E9%87%8D%E5%AD%A6-1-%E5%8D%95%E4%BD%8D/"/>
    <id>http://zhangliminabc.github.io/style-07-05-css%E9%87%8D%E5%AD%A6-1-%E5%8D%95%E4%BD%8D/</id>
    <published>2021-07-05T11:53:24.000Z</published>
    <updated>2021-07-05T11:53:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="css中的常用单位："><a href="#css中的常用单位：" class="headerlink" title="css中的常用单位："></a>css中的常用单位：</h4><p>设备像素： 设备屏幕实际拥有的像素点； 一般来说： 宽度方向有1920个像素点，长度方向有1080个像素点</p><p>逻辑像素： CSS的像素单位（css的px）其尺寸大小是想相对的， 也称谓独立像素</p><p>分辨率： 屏长的设备像素 * 屏宽的设备像素（1920 * 1080 )</p><p>ppi(pixels per inch): 像素密度，便是沿对角线没英寸长度的像素数目，越大显示的越细腻</p><p>缩放因子： 逻辑像素相对于设备像素的放大比例， 可通过window.devicePixelRatio获得</p><p>分辨率（设备像素） = 设备尺寸 * 像素密度</p><p>关系一：<br>  设备尺寸 × 像素密度 = 分辨率（设备像素）</p><p>举例：<br>  iphone6s 对角线长度为5.5 inches，像素密度401 ppi，分辨率 1920 * 1080，计算可得对角线的设备像素为2205.5。<br>  5.5 * 401 = 2205.5</p><p>关系二：<br>  逻辑像素(css的px) = 设备像素 × 缩放因子</p><p>举例：<br>  iphone6逻辑像素为375 * 667，分辨率为750 * 1334，缩放因子为2<br>  1个逻辑像素（1px） = 设备宽度的1/375<br>  1个设备像素 = 设备宽度的1/750</p><p>px: 独立像素</p><p>em: 根据父元素的字体大小来计算字体大小</p><p>rem: 相对于根元素html字体大小计算字体大小</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> docEl = win.document.documentElement;</span><br><span class="line"><span class="keyword">const</span> resiezeEvt = <span class="string">&#x27;orientationchange&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> refreshRem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> clientWidth = win.innerWidth || doc.documentElement.clientWidth || doc.body.clientWidth;</span><br><span class="line">   <span class="built_in">console</span>.log(clientWidth)</span><br><span class="line">   <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">let</span> fz;</span><br><span class="line">   <span class="keyword">const</span> width = clientWidth;</span><br><span class="line">   fz = <span class="number">16</span> * width / <span class="number">375</span>;</span><br><span class="line">   docEl.style.fontSize = fz + <span class="string">&#x27;px&#x27;</span>;<span class="comment">//这样每一份也是16px,即1rem=16px</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span><br><span class="line"> win.addEventListener(resizeEvt, refreshRem, <span class="literal">false</span>);</span><br><span class="line"> doc.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, refreshRem, <span class="literal">false</span>);</span><br><span class="line"> refreshRem();</span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;css中的常用单位：&quot;&gt;&lt;a href=&quot;#css中的常用单位：&quot; class=&quot;headerlink&quot; title=&quot;css中的常用单位：&quot;&gt;&lt;/a&gt;css中的常用单位：&lt;/h4&gt;&lt;p&gt;设备像素： 设备屏幕实际拥有的像素点； 一般来说： 宽度方向有1920个像素
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://zhangliminabc.github.io/categories/css/"/>
    
    
      <category term="CSS" scheme="http://zhangliminabc.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>重学js值(3)-super</title>
    <link href="http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B-3-super/"/>
    <id>http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B-3-super/</id>
    <published>2021-07-02T08:56:08.000Z</published>
    <updated>2021-07-02T08:56:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="super-用于访问和调用一个对象的父对象上的函数"><a href="#super-用于访问和调用一个对象的父对象上的函数" class="headerlink" title="super: 用于访问和调用一个对象的父对象上的函数"></a>super: 用于访问和调用一个对象的父对象上的函数</h4><h5 id="Object-getPrototypeOf-Object-setPrototypeOf-返回的是对象的隐士的原型对象-proto"><a href="#Object-getPrototypeOf-Object-setPrototypeOf-返回的是对象的隐士的原型对象-proto" class="headerlink" title="Object.getPrototypeOf / Object.setPrototypeOf: 返回的是对象的隐士的原型对象 proto"></a>Object.getPrototypeOf / Object.setPrototypeOf: 返回的是对象的隐士的原型对象 <strong>proto</strong></h5><h5 id="Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"><a href="#Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。" class="headerlink" title="Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"></a>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</h5><h4 id="babel编译super"><a href="#babel编译super" class="headerlink" title="babel编译super"></a>babel编译super</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">_getPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf ?</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf :</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(o);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> _getPrototypeOf(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_assertThisInitialized</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (self === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">&quot;this hasn&#x27;t been initialised - super() hasn&#x27;t been called&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (call &amp;&amp; (_typeof(call) === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> call === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperMethod</span>(<span class="params">subClass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="function"><span class="keyword">function</span>  <span class="title">_createSuperInternal</span>(<span class="params">subClass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 这两步参考extends</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">super</span> = _getPrototypeOf(subClass)</span><br><span class="line"><span class="keyword">const</span> newTarget =  _getPrototypeOf(<span class="built_in">this</span>).constructor</span><br><span class="line"><span class="comment">/** Reflect.constructor(super, constructor, newTarget) 相当于 =  </span></span><br><span class="line"><span class="comment">var obj2 = Object.create(newTarget.prototype);</span></span><br><span class="line"><span class="comment">super.apply(obj2, args);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">result = <span class="built_in">Reflect</span>.constructor(<span class="built_in">super</span>, <span class="built_in">arguments</span>, newTarget)</span><br><span class="line"><span class="keyword">return</span> _possibleConstructorReturn(<span class="built_in">this</span>, result) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;super-用于访问和调用一个对象的父对象上的函数&quot;&gt;&lt;a href=&quot;#super-用于访问和调用一个对象的父对象上的函数&quot; class=&quot;headerlink&quot; title=&quot;super: 用于访问和调用一个对象的父对象上的函数&quot;&gt;&lt;/a&gt;super: 用于访
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>重学js值(2)-extends</title>
    <link href="http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B(2)-extends/"/>
    <id>http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B(2)-extends/</id>
    <published>2021-07-02T04:11:58.000Z</published>
    <updated>2021-07-02T04:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"><a href="#Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。" class="headerlink" title="Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。"></a>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</h5><h4 id="先搞定清楚-prototype-和-proto之间的区别"><a href="#先搞定清楚-prototype-和-proto之间的区别" class="headerlink" title="先搞定清楚 prototype 和 proto之间的区别"></a>先搞定清楚 prototype 和 <strong>proto</strong>之间的区别</h4><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><pre><code>a, 拥有属性的对象不同</code></pre><p><strong>proto</strong>: 在js中， 万物皆为对象，对象具有<strong>proto</strong>属性，可称为隐式原型； 一个对象的隐式原型指向该对象的构造函数的原型（js的对象）</p><p>prototype: 函数这个特殊对象所特有的属性（原型属性）（函数）</p><pre><code>b,  指向不同</code></pre><p>1，<strong>proto</strong> 指向它的构造函数的原型对象（prototype ）</p><p>2，该原型对象也有一个自己的隐式原型( <strong>proto</strong> ) 和 constructor;<br>    constructor: 指向构造函数<br>    <strong>proto</strong>: 指向它的构造函数的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Test.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">Test.prototype.constructor === Test <span class="comment">// true</span></span><br><span class="line">Test.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="extends做了什么？？"><a href="#extends做了什么？？" class="headerlink" title="extends做了什么？？"></a>extends做了什么？？</h4><pre><code>extends在实现继承方面，本质上也是原型链继承,该方法实现了两步原型链继承    1）子类的__proto__属性，表示构造函数的继承，总是指向父类。（把子类构造函数(Child)的原型(__proto__)指向了父类构造函数(Parent)）    2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</code></pre><h4 id="自定义实现extends"><a href="#自定义实现extends" class="headerlink" title="自定义实现extends"></a>自定义实现extends</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">customExtends</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 创建以constructor对象为基准的__proto__ == superClass.prototype</span></span><br><span class="line">subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">      <span class="title">constructor</span>: &#123; </span><br><span class="line">value: subClass,</span><br><span class="line">writable: <span class="literal">true</span>,</span><br><span class="line">configurable: <span class="literal">true</span> </span><br><span class="line">&#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 2. 将子类的隐式原型设置为父类</span></span><br><span class="line">subClass.__proto__ = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="babel编译extends"><a href="#babel编译extends" class="headerlink" title="babel编译extends"></a>babel编译extends</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">&#x27;function&#x27;</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Super expression must either be null or a function &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line"><span class="title">constructor</span>: &#123;</span><br><span class="line">value: subClass,</span><br><span class="line">writable: <span class="literal">true</span>,</span><br><span class="line">configureable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> (superClass) &#123;</span><br><span class="line">_setPrototypeOf(subClass, superClass)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">_setPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf || <span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123; o.__proto__ = p; <span class="keyword">return</span> o&#125;</span><br><span class="line"><span class="comment">// subClass.__proto__ = superClass</span></span><br><span class="line"><span class="keyword">return</span> _setPrototypeOf(subClass, superClass)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。&quot;&gt;&lt;a href=&quot;#Object-create-方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="JavaScriptj" scheme="http://zhangliminabc.github.io/categories/javascriptj/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>重学js之(1)-new</title>
    <link href="http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B(1)-new/"/>
    <id>http://zhangliminabc.github.io/%E9%87%8D%E5%AD%A6js%E4%B9%8B(1)-new/</id>
    <published>2021-07-01T12:21:21.000Z</published>
    <updated>2021-07-01T12:21:21.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="new的作用"><a href="#new的作用" class="headerlink" title="new的作用"></a>new的作用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Test(<span class="string">&#x27;测试&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance.name) <span class="comment">// 测试</span></span><br><span class="line"></span><br><span class="line">instance.setName(<span class="string">&#x27;测试1&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance.name) <span class="comment">// 测试1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p> new 通过构造函数创建出来的实例可以访问构造函数中的属性</p><p> new 通过构造函数创建出来的实例可以访问原型链中的属性和方法； 也就是说通过new操作符实例和构造函数通过原型链连接起来了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">age</span>: <span class="number">24</span>&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Test(<span class="string">&#x27;yck&#x27;</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(t) <span class="comment">// &#123; age: 26 &#125;</span></span><br><span class="line">   <span class="built_in">console</span>.log(t.name) <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><p> 构造函数如果返回值为对象，那么这个返回值会被正常使用 </p><h6 id="自定义实现-new-操作符"><a href="#自定义实现-new-操作符" class="headerlink" title="自定义实现 new 操作符"></a>自定义实现 new 操作符</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNew</span>(<span class="params">Con, ...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">// 解释了static类型的方法不能通过this调用的原因</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, Con.prototype)</span><br><span class="line"><span class="comment">// apply方法调用一个具有给定this值的函数</span></span><br><span class="line"><span class="keyword">let</span> result = Con.apply(<span class="built_in">this</span>, args)</span><br><span class="line"><span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;new的作用&quot;&gt;&lt;a href=&quot;#new的作用&quot; class=&quot;headerlink&quot; title=&quot;new的作用&quot;&gt;&lt;/a&gt;new的作用&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>es深入浅出系列(2)</title>
    <link href="http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-2/"/>
    <id>http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-2/</id>
    <published>2021-06-09T13:22:41.000Z</published>
    <updated>2021-06-09T13:22:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>ES6 允许写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>解构赋值允许指定默认值。</p><p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [firstItem = []] = []</span><br><span class="line"></span><br><span class="line">firstItem <span class="comment">// []; 解构赋值在解构出来的值为undefined时，默认值才会生效</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;解构&quot;&gt;&lt;a href=&quot;#解构&quot; class=&quot;headerlink&quot; title=&quot;解构&quot;&gt;&lt;/a&gt;解构&lt;/h3&gt;&lt;p&gt;ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。&lt;/p&gt;
&lt;p&gt;以前，为变量赋值
      
    
    </summary>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/categories/ecmascript/"/>
    
      <category term="javascript" scheme="http://zhangliminabc.github.io/categories/ecmascript/javascript/"/>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>es深入浅出系列(1)</title>
    <link href="http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-1/"/>
    <id>http://zhangliminabc.github.io/ecmascript-06-09-es%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B3%BB%E5%88%97-1/</id>
    <published>2021-06-09T12:45:56.000Z</published>
    <updated>2021-06-09T12:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="let和const系列"><a href="#let和const系列" class="headerlink" title="let和const系列"></a>let和const系列</h4><h3 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not undefined</span></span><br><span class="line">b <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p>  const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const PI &#x3D; 3.1415</span><br><span class="line"></span><br><span class="line">PI &#x2F;&#x2F; 3.1415</span><br><span class="line"></span><br><span class="line">pI &#x3D; 3 &#x2F;&#x2F; TypeError: Assignment to constant variable</span><br></pre></td></tr></table></figure><p>const语法对于引用类型是可以更改和增加其属性值， 因为对于引用类型在内存中存储的是一个引用地址； 对于const命令不能将引用地址更改</p><p>1, let 和 const 的出现解决了什么问题？</p><pre><code>在es5中只有全局作用域和函数作用域，带来很多不合理的场景第一种场景： 内层变量覆盖外层变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;这不是时间&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 这不是时间， 原因在于用var 声明的变量存在变量提升， 导致函数执行时在当前函数作用域中就能找到对应的a变量因此进行了输出</span></span><br></pre></td></tr></table></figure>第二中场景： 变量泄露为全局变量<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= s.length-<span class="number">1</span>; i++</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 5; 原因在于 变量i用var 声明， 导致循环执行结束之后，变量i并没有销毁, 泄露成了全局变量</span></span><br></pre></td></tr></table></figure></code></pre><p>2, let 和const的共同点<br>    1, 没有变量提升<br>    2, 增加了块级作用域<br>    3, 必须先定义后使用, 都存在暂时性死区(在代码块内，使用<code>let</code>和 <code>const</code>命令声明变量之前，该变量都是不可用的变)<br>    4, 在同一个块级作用域中不能重复定义相同的变量</p><p>注意点：</p><ul><li>允许在块级作用域中声明函数</li><li>函数声明类似于 ‘var’，即会提升到全局作用域或者函数作用域的头部（var的变量声明）</li><li>函数声明还会提升到所在的块级作用域的头部</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>相当于运行以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;let和const系列&quot;&gt;&lt;a href=&quot;#let和const系列&quot; class=&quot;headerlink&quot; title=&quot;let和const系列&quot;&gt;&lt;/a&gt;let和const系列&lt;/h4&gt;&lt;h3 id=&quot;let-命令&quot;&gt;&lt;a href=&quot;#let-命令&quot; cla
      
    
    </summary>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/categories/ecmascript/"/>
    
    
      <category term="EcmaScript" scheme="http://zhangliminabc.github.io/tags/ecmascript/"/>
    
  </entry>
  
  <entry>
    <title>webrtc基础概念介绍</title>
    <link href="http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D/"/>
    <id>http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-06-07T11:55:07.000Z</published>
    <updated>2021-06-07T11:55:07.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="webrtc" scheme="http://zhangliminabc.github.io/categories/webrtc/"/>
    
    
      <category term="webrtc" scheme="http://zhangliminabc.github.io/tags/webrtc/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D-2/"/>
    <id>http://zhangliminabc.github.io/webrtc-rtc%E4%BB%8B%E7%BB%8D-2/</id>
    <published>2021-06-07T11:53:19.675Z</published>
    <updated>2021-06-07T11:53:19.675Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>nodejs介绍</title>
    <link href="http://zhangliminabc.github.io/nodejs-05-31-nodejs%E4%BB%8B%E7%BB%8D-2/"/>
    <id>http://zhangliminabc.github.io/nodejs-05-31-nodejs%E4%BB%8B%E7%BB%8D-2/</id>
    <published>2021-05-31T08:25:32.000Z</published>
    <updated>2021-05-31T08:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript: 定义了语法（本身只有语法和词法， 简称语法); 比如: 变量定义、循环、判断、函数、原型、原型链、作用域、闭包、异步<br>(ES教程)[<a href="https://es6.ruanyifeng.com/]">https://es6.ruanyifeng.com/]</a></p><p>javascript:  是用ES语法规范 + web API; 两者结合，即可完成浏览器端的任何操作<br>    web Api: BOM、DOM、事件绑定、Ajax、 websock等</p><p>nodejs: 使用ES语法规范 + nodejs api；</p>]]></content>
    
    <summary type="html">
    
      ECMAScript、javascript、nodejs的区别
    
    </summary>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/categories/nodejs/"/>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>nvm控制node版本</title>
    <link href="http://zhangliminabc.github.io/nodejs-05-31-nvm%E6%8E%A7%E5%88%B6node%E7%89%88%E6%9C%AC-1/"/>
    <id>http://zhangliminabc.github.io/nodejs-05-31-nvm%E6%8E%A7%E5%88%B6node%E7%89%88%E6%9C%AC-1/</id>
    <published>2021-05-31T08:19:58.000Z</published>
    <updated>2021-05-31T08:19:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>nvm 控制node 版本</p><p>nvm:  (github地址)[<a href="https://github.com/nvm-sh/nvm]">https://github.com/nvm-sh/nvm]</a></p><p>commender list:</p><ul><li>nvm list</li><li>nvm use</li><li>nvm install</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nvm 控制node 版本&lt;/p&gt;
&lt;p&gt;nvm:  (github地址)[&lt;a href=&quot;https://github.com/nvm-sh/nvm]&quot;&gt;https://github.com/nvm-sh/nvm]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;commender list:&lt;
      
    
    </summary>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/categories/nodejs/"/>
    
    
      <category term="NodeJs" scheme="http://zhangliminabc.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出11(面向对象)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA11(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA11(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1)/</id>
    <published>2021-05-10T12:00:09.000Z</published>
    <updated>2021-05-10T12:00:09.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-对象属性"><a href="#1-对象属性" class="headerlink" title="1. 对象属性"></a>1. 对象属性</h4><p><em>数据属性:</em><br>configurable: 能否通过 delete 删除属性从而重新定义属性，默认值 true<br>enumerable: 是否可以通过 forin 循环， 默认值 true<br>writable: 能否修改属性的值， 默认值 true<br>value： 获取修改属性的值。 默认值 undifined<br>Object.defineProperty( 属性所在的对象， 需要修改的属性名， 描述符对象)</p><p><em>访问器属性：</em><br>configurable: 能否通过 delete 删除属性从而重新定义属性，默认值 true<br>enumerable: 是否可以通过 forin 循环， 默认值 true<br>get: 获取属性值， 默认值 undifined<br>set：设置属性值。 默认值 undifined<br>访问器属性不能直接定义， 只能通过 Object.defineProperty 来定义<br>Object.defineProperties(target， {})</p><h4 id="hasOwnProperty-检测属性是否存在于实例中"><a href="#hasOwnProperty-检测属性是否存在于实例中" class="headerlink" title="hasOwnProperty: 检测属性是否存在于实例中"></a>hasOwnProperty: 检测属性是否存在于实例中</h4><h4 id="hasPrototypeProperty-检测对象中是否在原型中存在给定的属性"><a href="#hasPrototypeProperty-检测对象中是否在原型中存在给定的属性" class="headerlink" title="hasPrototypeProperty: 检测对象中是否在原型中存在给定的属性"></a>hasPrototypeProperty: 检测对象中是否在原型中存在给定的属性</h4><h4 id="in操作符-检测对象中是否存在给定的属性值"><a href="#in操作符-检测对象中是否存在给定的属性值" class="headerlink" title="in操作符: 检测对象中是否存在给定的属性值"></a>in操作符: 检测对象中是否存在给定的属性值</h4><h4 id="isPrototypeOf-对象之前是否存在存在某种关系"><a href="#isPrototypeOf-对象之前是否存在存在某种关系" class="headerlink" title="isPrototypeOf: 对象之前是否存在存在某种关系"></a>isPrototypeOf: 对象之前是否存在存在某种关系</h4><h4 id="getPrototypeof-获取对象的的隐式原型，即对象的proto属性"><a href="#getPrototypeof-获取对象的的隐式原型，即对象的proto属性" class="headerlink" title="getPrototypeof: 获取对象的的隐式原型，即对象的proto属性"></a>getPrototypeof: 获取对象的的隐式原型，即对象的<strong>proto</strong>属性</h4><h4 id="Object-getOwnPropertypeNames-得到所有的实例属性，无论它是否可枚举"><a href="#Object-getOwnPropertypeNames-得到所有的实例属性，无论它是否可枚举" class="headerlink" title="Object.getOwnPropertypeNames: 得到所有的实例属性，无论它是否可枚举"></a>Object.getOwnPropertypeNames: 得到所有的实例属性，无论它是否可枚举</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最新的定义访问器属性的方法</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  year: <span class="number">2004</span>,</span><br><span class="line">  editor: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._year;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._year = newValue + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.year); <span class="comment">//2006</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧版的定义访问器属性的方法</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  year: <span class="number">2004</span>,</span><br><span class="line">  editor: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">book.__defineGetter__(<span class="string">&quot;year&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.year;</span><br><span class="line">&#125;);</span><br><span class="line">book.__defineSetter__(<span class="string">&quot;year&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.year = newValue + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.year); <span class="comment">//2006</span></span><br></pre></td></tr></table></figure><h4 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2. 创建对象"></a>2. 创建对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.job = job;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;校长&quot;</span>, <span class="number">10</span>, <span class="string">&quot;softarea&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">20</span>, <span class="string">&quot;doctor&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;teacher&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;校长&quot;</span>, <span class="number">10</span>, <span class="string">&quot;softarea&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">20</span>, <span class="string">&quot;doctor&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor); <span class="comment">//Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isPrototypeOf： 验证对象之间是否存在关系</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//hasOwnProperty: 验证对象属性是存在于实例中还是原型中</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JavaScript深入浅出面向对象，剖析了js为什么说是面向对象，并从封装、继承、多态三方面来解释js的面向对象
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出10(原型链)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA10(%E5%8E%9F%E5%9E%8B%E9%93%BE)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA10(%E5%8E%9F%E5%9E%8B%E9%93%BE)/</id>
    <published>2021-05-08T07:45:28.000Z</published>
    <updated>2021-05-08T07:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="js-分为函数对象和普通对象"><a href="#js-分为函数对象和普通对象" class="headerlink" title="js 分为函数对象和普通对象"></a>js 分为函数对象和普通对象</h5><ul><li><b>每个对象都有<strong>proto</strong>属性，prototype 属性只有函数对象才有</b></li><li><b>属性<em>proto</em>是一个对象，有 constructor 和<em>proto</em>属性</b></li><li><b>原型对象 prototype 有一个默认的 constructor，记录是由那个构造函数创建的</b></li><li><b>实例(instance)都包含一个指向原型对象的内部指针(<strong>proto</strong>)</b></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment"> * &#123; getFatherValue: function,</span></span><br><span class="line"><span class="comment"> *   constructor: Father()&#123;&#125;,</span></span><br><span class="line"><span class="comment"> *   __proto__: Object</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则三： 原型对象prototype有一个默认的constructor，记录是由那个构造函数创建的</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype.constructor === Father); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">new</span> Father();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   constructor: Father()&#123;&#125;,</span></span><br><span class="line"><span class="comment"> *   __proto__: Object</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Father); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="js-查找规则"><a href="#js-查找规则" class="headerlink" title="js 查找规则"></a>js 查找规则</h5><ul><li><b>如果试图在对象或者实例上查找某个属性，回先从对象内部查找;</b></li><li><b>当查不到的时候，会在该对象的原型中去查找</b></li></ul><p><b style="color:red;">查找对象属性时形成的链式查找叫做原型链（实例和原型的关系）</b></p><h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><p>1, new 操作符内部做了什么</p>  <ul style="color: red;">    <li>创建一个空对象</li>    <li>将空对象的__proto__属性指向实例函数的原型对象(prototype)</li>    <li>使用call绑定函数内的this指向</li>    <li>返回空对象</li>  </ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createdNew</span>(<span class="params">fun1</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = fun1.prototype;</span><br><span class="line">  fun1.call(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="string">&quot;这是父类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = createdNew(Father);</span><br><span class="line"><span class="built_in">console</span>.log(instance1 <span class="keyword">instanceof</span> Father1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>2, 写一个继承函数</p><ul><li><p>组合继承</p><ul><li><p>问题：</p><p>调用了两次父类构造函数(一次为 Son 函数内， 一次为初始化子类实例时), 造成了不必要的消耗</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;black&quot;</span>];</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.sayColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.color.join(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = Parent.prototype;</span><br><span class="line"></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instanceSon = <span class="keyword">new</span> Son(<span class="string">&quot;zhanglimin&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链的查找是根据__proto__一层层向上查找</span></span><br><span class="line"><span class="built_in">console</span>.log(instanceSon.sayAge); <span class="comment">// Function</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype.sayAge); <span class="comment">// Function</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.age); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.sayColor); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li><p>原型继承: 借助原型可以基于已有的对象创建新对象</p><ul><li>问题:<br>对于引用类型的值在实例中数据共享</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  type: [<span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;black&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = object(person);</span><br><span class="line"><span class="built_in">console</span>.log(p1.type); <span class="comment">// [&quot;yellow&quot;, &quot;white&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line">p1.type.push(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = object(person);</span><br><span class="line"><span class="built_in">console</span>.log(p2.type); <span class="comment">// [&quot;yellow&quot;, &quot;white&quot;, &quot;black&quot;, test]</span></span><br></pre></td></tr></table></figure><ul><li>组合继承</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass, parentClass</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createdObjec</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个对象，使对象的__proto__ 指向需要继承的原型</span></span><br><span class="line">  <span class="keyword">const</span> prototype = createdObjec(parentClass.prototype);</span><br><span class="line">  <span class="comment">// constructor指向子类，因为js原型中的规则为constructor指向由谁创建</span></span><br><span class="line">  prototype.constructor = subClass;</span><br><span class="line">  <span class="comment">// 改变子类的原型对象的指向</span></span><br><span class="line">  subClass.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="string">&quot;这是父类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentClass.prototype.syaHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.b = <span class="string">&quot;这是子类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subClass.prototype.saySub = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extend(subClass, parentClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subInstance = <span class="keyword">new</span> subClass();</span><br><span class="line"><span class="built_in">console</span>.log(subInstance.syaHello); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(subInstance.saySub); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>3, 怎么理解原型链: 查找属性时会优先在当前的对象中查找，当查找不到的之后会在对于的原型上查找</p><h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h4><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call函数</a></p><h4 id="封装：属性和方法的封装"><a href="#封装：属性和方法的封装" class="headerlink" title="封装：属性和方法的封装"></a>封装：属性和方法的封装</h4><p>  1, 闭包<br>  2, 对象</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>原型式继承</li></ul><p>原型链实现继承的问题： 数据属性共享， 不能向父类传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型链</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;res&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">instance.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance.colors); <span class="comment">//[&quot;res&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//[&quot;res&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"><span class="comment">// instanceof: 确定实例和原型的关系</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1 <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>构造函数式继承</li></ul><p>问题: 不能继承父类原型链上的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;res&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubClass()</span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperClass) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.getColors()) <span class="comment">// TypeError: instance.getColors is not a function </span></span><br></pre></td></tr></table></figure><ul><li>组合继承</li></ul><p>父类函数执行两次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;block&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instan1 = <span class="keyword">new</span> SubClass(<span class="number">11</span>);</span><br><span class="line">instan1.colors.push(<span class="string">&#x27;test1&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instan1.colors); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27;, &#x27;test1&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instan2 = <span class="keyword">new</span> SubClass(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instan2.colors, <span class="string">&#x27;属性&#x27;</span>); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27; ] 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(instan2.getColors()); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>寄生式继承</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPropotype</span>(<span class="params">ParentClass</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  f.prototype = ParentClass;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ParentClass.prototype.setColors = <span class="function"><span class="keyword">function</span> (<span class="params">colorName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors.push(colorName);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ParentClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ParentClass.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Extends</span>(<span class="params">parent, sub</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = inheritPropotype(parent.prototype);</span><br><span class="line">  p.construcor = sub;</span><br><span class="line">  sub.prototype = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Extends(ParentClass, SubInstance);</span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubInstance();</span><br><span class="line">sub1.setColors(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.getColors());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sub2 = <span class="keyword">new</span> SubInstance();</span><br><span class="line">sub2.setColors(<span class="string">&#x27;block&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub2.getColors());</span><br></pre></td></tr></table></figure><h4 id="多态：-同一种方法多种调用方式"><a href="#多态：-同一种方法多种调用方式" class="headerlink" title="多态： 同一种方法多种调用方式"></a>多态： 同一种方法多种调用方式</h4><p>js中函数参数可以通过arguments获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Polymorphism</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> argsLen = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">if</span> (argsLen &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Polymorphism(<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js的原型链
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出9(闭包)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA9(%E9%97%AD%E5%8C%85)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA9(%E9%97%AD%E5%8C%85)/</id>
    <published>2021-05-08T07:40:19.000Z</published>
    <updated>2021-05-08T07:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><h6 id="js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法"><a href="#js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法" class="headerlink" title="js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法"></a>js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法</h6><h6 id="通俗的解释是函数返回函数，我的理解是"><a href="#通俗的解释是函数返回函数，我的理解是" class="headerlink" title="通俗的解释是函数返回函数，我的理解是"></a>通俗的解释是函数返回函数，我的理解是</h6><h6 id="闭包就是能够读取其他函数内部变量的函数。由于在-Javascript-语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”"><a href="#闭包就是能够读取其他函数内部变量的函数。由于在-Javascript-语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”" class="headerlink" title="闭包就是能够读取其他函数内部变量的函数。由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”"></a>闭包就是能够读取其他函数内部变量的函数。由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”</h6><p><b style="color:red;">所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</b></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;全局属性&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">&quot;这是对象中的值&quot;</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()); <span class="comment">// My Object</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js中的作用域只有全局和函数作用域，在某些特殊其情况下需要在函数之外获取函数内定义的一些变量和方法， 这就是闭包
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript深入浅出8(作用域)</title>
    <link href="http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA8(%E4%BD%9C%E7%94%A8%E5%9F%9F)/"/>
    <id>http://zhangliminabc.github.io/javascript%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA8(%E4%BD%9C%E7%94%A8%E5%9F%9F)/</id>
    <published>2021-05-08T07:35:47.000Z</published>
    <updated>2021-05-08T07:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作用域-js中的作用域只有函数作用域和全局作用域"><a href="#作用域-js中的作用域只有函数作用域和全局作用域" class="headerlink" title="作用域: (js中的作用域只有函数作用域和全局作用域)"></a>作用域: (js中的作用域只有函数作用域和全局作用域)</h4><p><b>确定当前执行代码对标识符的访问权限</b></p><ul><li><p>函数的作用域: 函数产生一层函数作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(b * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数的作用域</span></span><br><span class="line"><span class="comment"> * 1, 全局window下foo</span></span><br><span class="line"><span class="comment"> * 2, foo下有a, b, bar</span></span><br><span class="line"><span class="comment"> * 3, bar下有c, 当需要查找b，a的值时在当前对象下不能找到会向上级foo下的作用域寻找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">foo(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>模拟块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockBlaockScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// a is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">mockBlaockScope();</span><br></pre></td></tr></table></figure></li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>1, 使用 es5 模拟块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockScoptBlock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;这是块级作用于内的函数&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// error, a is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2, 解决循环输出的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scopeFun();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  output: 5,5,5,5,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案: 使用自执行函数生成函数内的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      js中的作用域只有函数作用域和全局作用域
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://zhangliminabc.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
