<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>babel</title>
    <url>/2020/06/19/babel/babel/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>function</title>
    <url>/2020/04/20/javascript/function/</url>
    <content><![CDATA[<ul>
<li><p>概述</p>
<hr style="margin: 5px 0px; background-image: none;     border-top: 1px solid #fff;"/>

<p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值</p>
</li>
<li><p>声明(Function Declaration)</p>
<hr style="margin: 5px 0px; background-image: none;     border-top: 1px solid #fff;"/>

<p>1.function 命令声明的代码区块，就是一个函数。function 命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面</p>
</li>
</ul>
  <a id="more"></a>

  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  2.函数表达式， 将匿名函数赋值给变量，这是这个匿名函数叫函数表达式</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> functionVar = <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(params);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 带有函数名的函数表达式</span></span><br><span class="line"><span class="keyword">var</span> funtionWithName = <span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> functionName);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面代码在函数表达式中，加入了函数名functionName。这个functionName只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）</span></span><br><span class="line"><span class="comment">  * ReferenceError: functionName is not defined</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">functionName(<span class="string">&quot;这是参数有参数的函数表达式);</span></span><br></pre></td></tr></table></figure>

<p>  3.Function 构造函数</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot; return x + y&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  retuen x + u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数的重复声明<br>如果同一个函数被多次声明， 后面的会覆盖前面的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;这是第一个函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;这是重复声明的函数， 这个函数会覆盖第一个函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * result =&gt; 这是重复声明的函数， 这个函数会覆盖第一个函数</span></span><br><span class="line"><span class="comment"> * 原因： js中的函数本身属于一个挂载到window对象上的一个属性值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">firstFunc();</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性和方法</p>
</li>
<li><p>递归</p>
</li>
<li><p>作用域</p>
<p>在 es5 中 JavaScript 只有两种作用域， 一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在</p>
<p>函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;这是全局作用域的变量&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * result =&gt; 这是全局作用域的变量</span></span><br><span class="line"><span class="comment"> *  在函数体内可以访问具有全局作用域的变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">globalFun();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funVar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">&quot;这是函数体内定义的变量&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReferenceError: b is not defined</span></span><br><span class="line"><span class="comment"> * 函数内定义的变量不能再函数体之外访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果在函数体内存在跟全局变量相同的局部变量，局部变量会覆盖全部变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">f();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(v);</span><br></pre></td></tr></table></figure>

<p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var 命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// firstFun 函数的作用域是全局的</span></span><br><span class="line"><span class="keyword">var</span> firstFun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">souncedFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  firstFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * result =&gt; 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">souncedFun();</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
</li>
<li><p>闭包<br>定义在函数体内的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parentFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Uncaught ReferenceError: n is not defined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结： 函数内部可以直接读取全局变量，但是函数外部无法读取函数内部声明的变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改造之后的函数体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parentFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * result =&gt; 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(parentFun());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖: 防抖是任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行，一般用于输入框实时搜索</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 节流: 节流是规定函数在指定的时间间隔内只执行一次，一般用于scroll事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>立即调用函数<br>在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数</p>
</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>function</title>
    <url>/2020/04/20/javascript/ecmaScript/demo/</url>
    <content><![CDATA[<ul>
<li><p>js的内存的数结构</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>将一个对象赋值给obj变量，js引擎会先在队内存中生成一个对象，然将堆内存的地址赋值给变量obj， 所以实际上变量obj指向的是一个堆内存地址</p>
 <p style="color: red;">也就是说，变量obj是一个地址（reference）。后面如果要读取obj.a，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的a属性</p>

 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">     a: <span class="number">1</span>,</span><br><span class="line">     getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line">obj.f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
  <img src="./image/js中的this.png">
</li>
<li><p>普通函数的this指向函数运行时所在的环境</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>) <span class="comment">// true</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数指向函数所在的作用域</p>
</li>
<li><p>js中this指向的情况</p>
<ol>
<li>函数作为对象的属性</li>
<li><span style="color: red;">通过apply, bind等方法显示改变this的值</span></li>
<li><span style="color: red;">通过new 关键词实例化函数, this指向初始化的函数</span></li>
<li>自执行函数中的this指向window</li>
<li>函数作为对象的属性，但是不通过对象的调用， this指向window</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>function</title>
    <url>/2020/04/20/javascript/ecmaScript/grammar/</url>
    <content><![CDATA[<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol>
<li><p>区分大小写: js 中的变量、函数、操作符都区分大小写</p>
</li>
<li><p>标识符: 变量、函数、属性的名字</p>
<ul>
<li>标识符有字母、数字、下划线、美元符号$组成<ul>
<li>第一个字符必须是字符、下划线、美元符号</li>
<li>关键字不能作为标识符</li>
</ul>
</li>
</ul>
</li>
<li><p>注释: 单行注释和多行注释</p>
</li>
<li><p>严格模式</p>
</li>
<li><p>语句: js 中的语句以;结尾</p>
<ul>
<li>虽然分号不是必须的，但是加上也会在某些情况下增加代码的性能</li>
</ul>
</li>
<li><p>关键字和保留字</p>
<ul>
<li>关键字和保留字不能用作标识符</li>
</ul>
</li>
<li><p><span style="color: red;">变量: ECMAScript 的变量是松散类型，松散类型可以保存任何类型的数据</span></p>
<ul>
<li><p>定义变量使用 var 关键字，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">// 定义变量但未初始化，默认值为undifined</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>function</title>
    <url>/2020/04/20/javascript/ecmaScript/prototype/</url>
    <content><![CDATA[<h3 id="js-的原型链"><a href="#js-的原型链" class="headerlink" title="js 的原型链"></a>js 的原型链</h3><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://juejin.im/post/6844903475021627400#heading-0">原型链讲解</a></p>
<h5 id="js-分为函数对象和普通对象"><a href="#js-分为函数对象和普通对象" class="headerlink" title="js 分为函数对象和普通对象"></a>js 分为函数对象和普通对象</h5><ul>
<li><p><b>每个对象都有<strong>proto</strong>属性，prototype 属性只有函数对象才有</b></p>
</li>
<li><p><b>属性<em>proto</em>是一个对象，有 constructor 和<em>proto</em>属性</b></p>
</li>
<li><p><b>原型对象 prototype 有一个默认的 constructor，记录是由那个构造函数创建的</b></p>
</li>
<li><p><b>实例(instance)都包含一个指向原型对象的内部指针(<strong>proto</strong>)</b></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment"> * &#123; getFatherValue: function,</span></span><br><span class="line"><span class="comment"> *   constructor: Father()&#123;&#125;,</span></span><br><span class="line"><span class="comment"> *   __proto__: Object</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规则三： 原型对象prototype有一个默认的constructor，记录是由那个构造函数创建的</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype.constructor === Father); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">new</span> Father();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   constructor: Father()&#123;&#125;,</span></span><br><span class="line"><span class="comment"> *   __proto__: Object</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Father); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="js-查找规则"><a href="#js-查找规则" class="headerlink" title="js 查找规则"></a>js 查找规则</h5><ul>
<li><b>如果试图在对象或者实例上查找某个属性，回先从对象内部查找;</b></li>
<li><b>当查不到的时候，会在该对象的原型中去查找</b></li>
</ul>
<p><b style="color:red;">查找对象属性时形成的链式查找叫做原型链（实例和原型的关系）</b></p>
<h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><p>1, new 操作符内部做了什么</p>
  <ul style="color: red;">
    <li>创建一个空对象</li>
    <li>将空对象的__proto__属性指向实例函数的原型对象(prototype)</li>
    <li>使用call绑定函数内的this指向</li>
    <li>返回空对象</li>
  </ul>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createdNew</span>(<span class="params">fun1</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = fun1.prototype;</span><br><span class="line">  fun1.call(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="string">&quot;这是父类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = createdNew(Father);</span><br><span class="line"><span class="built_in">console</span>.log(instance1 <span class="keyword">instanceof</span> Father1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>2, 写一个继承函数</p>
<ul>
<li><p>组合继承</p>
<ul>
<li><p>问题：</p>
<p>调用了两次父类构造函数(一次为 Son 函数内， 一次为初始化子类实例时), 造成了不必要的消耗</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;black&quot;</span>];</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.sayColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.color.join(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = Parent.prototype;</span><br><span class="line"></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instanceSon = <span class="keyword">new</span> Son(<span class="string">&quot;zhanglimin&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链的查找是根据__proto__一层层向上查找</span></span><br><span class="line"><span class="built_in">console</span>.log(instanceSon.sayAge); <span class="comment">// Function</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype.sayAge); <span class="comment">// Function</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.age); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.sayColor); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>原型继承: 借助原型可以基于已有的对象创建新对象</p>
<ul>
<li>问题:<br>对于引用类型的值在实例中数据共享</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  type: [<span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;black&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = object(person);</span><br><span class="line"><span class="built_in">console</span>.log(p1.type); <span class="comment">// [&quot;yellow&quot;, &quot;white&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line">p1.type.push(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = object(person);</span><br><span class="line"><span class="built_in">console</span>.log(p2.type); <span class="comment">// [&quot;yellow&quot;, &quot;white&quot;, &quot;black&quot;, test]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>组合继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass, parentClass</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createdObjec</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个对象，使对象的__proto__ 指向需要继承的原型</span></span><br><span class="line">  <span class="keyword">const</span> prototype = createdObjec(parentClass.prototype);</span><br><span class="line">  <span class="comment">// constructor指向子类，因为js原型中的规则为constructor指向由谁创建</span></span><br><span class="line">  prototype.constructor = subClass;</span><br><span class="line">  <span class="comment">// 改变子类的原型对象的指向</span></span><br><span class="line">  subClass.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="string">&quot;这是父类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentClass.prototype.syaHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.b = <span class="string">&quot;这是子类&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subClass.prototype.saySub = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extend(subClass, parentClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subInstance = <span class="keyword">new</span> subClass();</span><br><span class="line"><span class="built_in">console</span>.log(subInstance.syaHello); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(subInstance.saySub); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>3, 怎么理解原型链: 查找属性时会优先在当前的对象中查找，当查找不到的之后会在对于的原型上查找</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>function</title>
    <url>/2020/04/20/javascript/ecmaScript/operator/</url>
    <content><![CDATA[<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ol>
<li><p>位操作符</p>
</li>
<li><p>一元操作符: 只能操作一个值的操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  转换规则</span></span><br><span class="line"><span class="comment"> *  1. boolean: 转成0|1,在执行操作； 布尔类型的值变成数值型</span></span><br><span class="line"><span class="comment"> *  2. string： 非有效字符串将字符串值设置为NaN,  有效的数字字符字符串的时候先将其转换为有效数字</span></span><br><span class="line"><span class="comment"> *  3. 应用与对象的时候先调用valueof方法如果是NaN，则会在次调用tostring方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>function</title>
    <url>/2020/04/20/javascript/ecmaScript/statement/</url>
    <content><![CDATA[<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol>
<li>if语句</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if (condition) statement1 esle statement2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  condition: 可以为任意的表达式，而且对这个值的求职结果不一定是布尔值。js自动会对condition的值调用boolean方法去转* 为布尔值</span></span><br><span class="line"><span class="comment"> * 如果condition为true就在执行statement1, 否则就执行statement2语句。这个两个语句可以是一句代码，也可以是个代码块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">25</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fyrgfyr&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>do-while 语句: 是一种后测试语句</p>
<p>只有在循环体的中的代码执行完之后才会测试出口条件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * do&#123;statement&#125; whild(expressiong)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &gt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>while 语句: 前测试循环语句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  while(expression) statement</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"> <span class="function"><span class="title">while</span>(<span class="params"> i&lt; = <span class="number">10</span> </span>)</span> &#123;</span><br><span class="line">   i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 语句: 前测试循环语句</p>
<ul>
<li><p>有执行循环之前初始化变量和定义循环后要执行的代码的能力</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for(initalnition; expressiong; loop-expressiong) statement</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>forin 语句: 是一种精准的迭代语句，用来枚举对象的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for(property in expression) statement</span></span><br><span class="line"><span class="keyword">for</span> (pro <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pro);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>break 和 continue 语句: 用于在循环中精确的控制代码的执行</p>
<ul>
<li>break: 会立即退出循环, 强制执行循环语句后面的语句</li>
<li>countinue: 会立即退出循环, 但是退出循环之后会从循环的顶部立即执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>switch 语句: 在比较时是采用全等操作符，因此不会发生类型装换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果表达式等于这个值，则执行后面的语句</span></span><br><span class="line"><span class="comment">* switch(express)</span></span><br><span class="line"><span class="comment">* case value: statement</span></span><br><span class="line"><span class="comment">*   break;</span></span><br><span class="line"><span class="comment">* case value: statement</span></span><br><span class="line"><span class="comment">*   break;</span></span><br><span class="line"><span class="comment">* default: statement</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>function</title>
    <url>/2020/04/20/javascript/ecmaScript/typeData/</url>
    <content><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p><span style="color: red;"> 基本数据类型: undefined、 null、 string、 boolean、 number</span></p>
</li>
<li><p><span style="color: red;">引用数据类型: object</span></p>
</li>
<li><p>typeof(类型监测)</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * undefined: 这个值未定义</span></span><br><span class="line"><span class="comment"> * boolean: 布尔类型</span></span><br><span class="line"><span class="comment"> * string: 字符串</span></span><br><span class="line"><span class="comment"> * number: 数字</span></span><br><span class="line"><span class="comment"> * object: objetc 或者 null</span></span><br><span class="line"><span class="comment"> * function: 函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;这是测试&quot;</span>;</span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;string&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;boolean&quot;</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;number&quot;</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;object&quot;</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;function&quot;</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> message === <span class="string">&quot;undefined&quot;</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ol>
<li>undefined: 声明未初始化</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用场景：</span></span><br><span class="line"><span class="comment"> * 1. 变量声明但没赋值</span></span><br><span class="line"><span class="comment"> * 2. 调用函数时该传入的参数没传</span></span><br><span class="line"><span class="comment"> * 3. 函数没有返回值时默认返回undefined</span></span><br><span class="line"><span class="comment"> * 4. 对象中属性值没有赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>null: null 是一个空对象指针,代表的是一个空对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* 使用场景：</span></span><br><span class="line"><span class="comment"> *  1. 定义的变量在将来用来保存对象</span></span><br><span class="line"><span class="comment"> *  2. 在一个数据不再使用的时候，我们最好将其值设置为null来释放其引用，以便垃圾回收下一次对其回收</span></span><br><span class="line"><span class="comment"> *  3. 作为对象原型链的终端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>boolean 布尔类型, 可以对任意类型的数据结构调用 boolean()进行转换</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* 转换规则：</span></span><br><span class="line"><span class="comment"> * 1. 字符串： 任意非空类型的字符串-&gt;true, 空类型的字符串-&gt;false</span></span><br><span class="line"><span class="comment"> * 2. number: 任何非0数字,包括正(负)的无穷大-&gt; true,</span></span><br><span class="line"><span class="comment"> * 3. object: 任何对象-&gt;true</span></span><br><span class="line"><span class="comment"> * 4. undefined: undefined -&gt;false</span></span><br><span class="line"><span class="comment"> * 5, null: null -&gt; false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(-<span class="number">0.4774</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>number: 数值转换(Number, parseInt, parseFloat)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 转换规则</span></span><br><span class="line"><span class="comment"> * 1. boolean: true -&gt; 1, false -&gt; 0</span></span><br><span class="line"><span class="comment"> * 2. number: 简单的传入和返回</span></span><br><span class="line"><span class="comment"> * 3. null: null -&gt; 0</span></span><br><span class="line"><span class="comment"> * 4. undefined: undefined -&gt; 0</span></span><br><span class="line"><span class="comment"> * 5. 字符串: 字符串为空 -&gt; 0; 字符串包含十六进制 -&gt; 转换为十六进制的值; 字符串包含数字 -&gt; 十进制的数值</span></span><br><span class="line"><span class="comment"> * 6. object: 对象 -&gt; valueOf方法按照上述规则转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;hello wrod&quot;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;000011&quot;</span>); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  parseInt: 忽略字符串前面的空格，找到第一个非空字符串，如果第一个字符不是数* 字或者负号返回NaN; 如果第一个字符是数字就会继续解析第二个字符，直到字符不是* 数字为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;1266rhfur&quot;</span>); <span class="comment">// 1266</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;rufgrfr&quot;</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * parseFloat: 从第一个字符开始解析; 解析遇到第一个无效的浮点数字字符或者* 字符串最后为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;23.38434.8484&quot;</span>); <span class="comment">// 23.38434</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;frfr&quot;</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>string: 转为字符串</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 将一个值转为字符串</span></span><br><span class="line"><span class="comment"> *  toString方法</span></span><br><span class="line"><span class="comment"> *  number、boolean、Object、 string都有toString方式, 多数情况下调用toString方法不用传* 参数， 但是对于number类型可以传一个参数代表返回的进制, 一般情况下是以十进制返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = <span class="number">11</span>;</span><br><span class="line">message.toString(); <span class="comment">// &#x27;11&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">num.toString(<span class="number">16</span>); <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在不知道转换的值的类型时可以使用String方法转成string类型，然后调用tostring方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">String</span>(a).toString(); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>object: 一组数据和功能的集合, object 是所有它的实例基础</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** object类型的实例方式</span></span><br><span class="line"><span class="comment"> *  1. hasOwnProperty(propertyName) : 检查给定的属性是否存在当前实例上而不是原型上</span></span><br><span class="line"><span class="comment"> *  2. valueOf: 返回字符串，通常与toString方法返回值相同</span></span><br><span class="line"><span class="comment"> *  3. tostring: 返回对象的字符串标识</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>es-class</title>
    <url>/2020/04/20/es6/es-class/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/04/10/git/index/</url>
    <content><![CDATA[<h4 id="git-安装"><a href="#git-安装" class="headerlink" title="git 安装"></a>git 安装</h4><ol>
<li>homebrew 安装<br><a href="https://www.jianshu.com/p/7edb6b838a2e">git 安装</a><br><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE">git 资料</a></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装Homebrew</span></span><br><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br><span class="line"><span class="comment"># 安装git</span></span><br><span class="line">brew install git</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>git 常用命令：</p>
<ul>
<li>git init: 初始化一个 Git 仓库</li>
<li>git clone: 从远端拉取一个 git 仓库到本地</li>
<li>git tag: 查看 tag 列表</li>
<li>git tag ${tagName}: 在当前提交上打上 tag</li>
<li>git push origin ${tagName}: 把 tagName 提交到代码服务器</li>
<li>git tag –delete ${tagName}: 删除本地 tag</li>
<li>git push origin :${tagName} &amp;&amp; git tag –delete ${tagName}: 删除本地和远程的标签</li>
<li>git symbolic-ref –short HEAD： 获取当前分支的名字</li>
<li>git remote get-url origin： 获取远程 git 仓库地址</li>
<li>git tag -l –points-at HEAD： 获取当前 commit 上的 tag</li>
<li>git branch： 查看所有的分支</li>
<li>git branch ${tagName} ： 删除本地分支</li>
<li>git branch -ｒ： 查看远端所有的分支</li>
<li>git branch -a: 查看本地和远端的分支</li>
<li>git branch -d: 删除本地分支</li>
<li>git push origin –delete ${branchName}: 删除远端分支</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>es-generator</title>
    <url>/2020/04/06/es6/es-generator/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>
<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征。<br>一是，<code>function</code>关键字与函数名之间有一个星号；<br>二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ending&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p>
<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p>
<p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码一共调用了四次<code>next</code>方法。</p>
<p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>
<p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>
<p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p>
<p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p>
<p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p>
<p>ES6 没有规定，<code>function</code>关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure>

<p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在<code>function</code>关键字后面。本书也采用这种写法。</p>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>js-面向对象</title>
    <url>/2020/04/06/javascript/js-oop/</url>
    <content><![CDATA[<h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h4><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call函数</a></p>
<h4 id="封装：属性和方法的封装"><a href="#封装：属性和方法的封装" class="headerlink" title="封装：属性和方法的封装"></a>封装：属性和方法的封装</h4><p>  1, 闭包<br>  2, 对象</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>原型式继承</li>
</ul>
<p>原型链实现继承的问题： 数据属性共享， 不能向父类传参</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型链</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;res&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">instance.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance.colors); <span class="comment">//[&quot;res&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//[&quot;res&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"><span class="comment">// instanceof: 确定实例和原型的关系</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1 <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数式继承</li>
</ul>
<p>问题: 不能继承父类原型链上的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;res&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubClass()</span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperClass) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.getColors()) <span class="comment">// TypeError: instance.getColors is not a function </span></span><br></pre></td></tr></table></figure>

<ul>
<li>组合继承</li>
</ul>
<p>父类函数执行两次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;block&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instan1 = <span class="keyword">new</span> SubClass(<span class="number">11</span>);</span><br><span class="line">instan1.colors.push(<span class="string">&#x27;test1&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instan1.colors); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27;, &#x27;test1&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instan2 = <span class="keyword">new</span> SubClass(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instan2.colors, <span class="string">&#x27;属性&#x27;</span>); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27; ] 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(instan2.getColors()); <span class="comment">// [ &#x27;red&#x27;, &#x27;block&#x27; ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>寄生式继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPropotype</span>(<span class="params">ParentClass</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  f.prototype = ParentClass;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ParentClass.prototype.setColors = <span class="function"><span class="keyword">function</span> (<span class="params">colorName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors.push(colorName);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ParentClass.prototype.getColors = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.colors;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ParentClass.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Extends</span>(<span class="params">parent, sub</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = inheritPropotype(parent.prototype);</span><br><span class="line">  p.construcor = sub;</span><br><span class="line">  sub.prototype = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Extends(ParentClass, SubInstance);</span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubInstance();</span><br><span class="line">sub1.setColors(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.getColors());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sub2 = <span class="keyword">new</span> SubInstance();</span><br><span class="line">sub2.setColors(<span class="string">&#x27;block&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub2.getColors());</span><br></pre></td></tr></table></figure>

<h4 id="多态：-同一种方法多种调用方式"><a href="#多态：-同一种方法多种调用方式" class="headerlink" title="多态： 同一种方法多种调用方式"></a>多态： 同一种方法多种调用方式</h4><p>js中函数参数可以通过arguments获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Polymorphism</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> argsLen = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">if</span> (argsLen &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Polymorphism(<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js对象</title>
    <url>/2020/04/06/javascript/jsObject/</url>
    <content><![CDATA[<h3 id="js-对象"><a href="#js-对象" class="headerlink" title="js 对象"></a>js 对象</h3><h4 id="1-对象属性"><a href="#1-对象属性" class="headerlink" title="1. 对象属性"></a>1. 对象属性</h4><p><em>数据属性:</em><br>configurable: 能否通过 delete 删除属性从而重新定义属性，默认值 true<br>enumerable: 是否可以通过 forin 循环， 默认值 true<br>writable: 能否修改属性的值， 默认值 true<br>value： 获取修改属性的值。 默认值 undifined<br>Object.defineProperty( 属性所在的对象， 需要修改的属性名， 描述符对象)</p>
<p><em>访问器属性：</em><br>configurable: 能否通过 delete 删除属性从而重新定义属性，默认值 true<br>enumerable: 是否可以通过 forin 循环， 默认值 true<br>get: 获取属性值， 默认值 undifined<br>set：设置属性值。 默认值 undifined<br>访问器属性不能直接定义， 只能通过 Object.defineProperty 来定义<br>Object.defineProperties(target， {})</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最新的定义访问器属性的方法</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  year: <span class="number">2004</span>,</span><br><span class="line">  editor: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._year;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._year = newValue + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.year); <span class="comment">//2006</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧版的定义访问器属性的方法</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  year: <span class="number">2004</span>,</span><br><span class="line">  editor: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">book.__defineGetter__(<span class="string">&quot;year&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.year;</span><br><span class="line">&#125;);</span><br><span class="line">book.__defineSetter__(<span class="string">&quot;year&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.year = newValue + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.year); <span class="comment">//2006</span></span><br></pre></td></tr></table></figure>

<h4 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2. 创建对象"></a>2. 创建对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.job = job;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;校长&quot;</span>, <span class="number">10</span>, <span class="string">&quot;softarea&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">20</span>, <span class="string">&quot;doctor&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;teacher&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;校长&quot;</span>, <span class="number">10</span>, <span class="string">&quot;softarea&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">20</span>, <span class="string">&quot;doctor&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor); <span class="comment">//Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isPrototypeOf： 验证对象之间是否存在关系</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//hasOwnProperty: 验证对象属性是存在于实例中还是原型中</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js 基本概念</title>
    <url>/2020/04/03/javascript/basic/</url>
    <content><![CDATA[<h1 id="js-基本概念"><a href="#js-基本概念" class="headerlink" title="js 基本概念"></a>js 基本概念</h1><h2 id="语法，-变量，-数据类型"><a href="#语法，-变量，-数据类型" class="headerlink" title="语法， 变量， 数据类型"></a>语法， 变量， 数据类型</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.区分大小写, a 和A 是两个不同的变量。改变其中一个值不会影响另一个变量的值</span></span><br><span class="line"><span class="comment">  2.标识符： 变量，函数，的名字；字母.数字.下划线.美元符号组成; 第一个字母必须是数字， 下划线， 美元符号组成， 采用驼峰式命名</span></span><br><span class="line"><span class="comment">  3.注释</span></span><br><span class="line"><span class="comment">  4.严格模式</span></span><br><span class="line"><span class="comment">  5.语句</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> A = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a == A); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="comment">// 变量声明未定义</span></span><br><span class="line"><span class="keyword">var</span> message;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">//undefind 变量声明未定义</span></span><br><span class="line"><span class="comment">// 变量作用域, 在函数内部使用var声明变量表示该变量只能在函数内访问，不使用var表示该变量属于全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&quot;this is a functon scope&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//this is a functon scope</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefind</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据类型， 基本数据类型： null, undefind, boolean, string, number, 引用类型： object</span></span><br><span class="line"><span class="keyword">var</span> _typeVariable = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">typeof</span> _typeVariable == <span class="string">&quot;string&quot;</span>; <span class="comment">//true</span></span><br><span class="line"><span class="comment">// typeof 可能的值： undefind, boolean, string, number, object, function</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
